% +------------------------------------------------------------------------+
% | Reference manual page: Parameterization_polyhedron_adaptor_3.tex
% +------------------------------------------------------------------------+
% | 13.09.2005   Laurent Saboret, Pierre Alliez, Bruno Levy
% | Package: Surface_mesh_parameterization
% |
\RCSdef{\RCSMeshadaptorpolyhedronRev}{$Id$}
\RCSdefDate{\RCSMeshadaptorpolyhedronDate}{$Date$}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Parameterization_polyhedron_adaptor_3<Polyhedron_3_>}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries


\ccDefinition

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

\ccc{Parameterization_polyhedron_adaptor_3} is an adaptor class to access to a Polyhedron 3D mesh using the \ccc{ParameterizationPatchableMesh_3} interface. Among other things, this concept defines the accessor to the (u, v) values computed by parameterizations methods.

Note that these interfaces are decorators that add {\em on the fly} the necessary fields to unmodified \cgal\ data structures (using STL maps). For performance reasons, it is recommended to use \cgal\ data structures enriched with the proper fields.

A \ccc{ParameterizationMesh_3} surface consists of vertices, facets and an incidence relation on them. No notion of edge is requested.

\ccc{ParameterizationMesh_3} meshes can have any genus, arity or number of components.

It can have have any number of borders. Its {\em main border} will be the mesh's longest border (if there is at least one border).

It has also the ability to support patches and virtual seams. {\em Patches} are a subset of a 3D mesh. {\em Virtual seams} are the ability to behave exactly as if the surface was cut following a certain path.

%END-AUTO(\ccDefinition)

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccInclude)

\ccInclude{CGAL/Parameterization_polyhedron_adaptor_3.h}

%END-AUTO(\ccInclude)


\ccIsModel

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccIsModel)

Model of \ccc{ParameterizationPatchableMesh_3} concept, whose purpose is to allow the \ccc{Surface_mesh_parameterization} package to access meshes in a uniform manner.

%END-AUTO(\ccIsModel)


\ccHeading{Design Pattern}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccHeading{Design Pattern})

\ccc{Parameterization_polyhedron_adaptor_3} is an Adaptor \cite{cgal:ghjv-dpero-95}: it changes the Polyhedron interface to match the \ccc{ParameterizationPatchableMesh_3} concept.

%END-AUTO(\ccHeading{Design Pattern})


\ccParameters

The full template declaration is:

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$class \ccc{Polyhedron_3_}$>$   \\
class \ccc{Parameterization_polyhedron_adaptor_3};

%END-AUTO(\ccParameters)

\ccc{Polyhedron_3_} must be of type \ccc{CGAL::Polyhedron<Traits>} and \ccc{Traits}
must be a model of the concept \ccc{PolyhedronTraitsWithKernel_3}.

\ccTypes

The following mutable handles, iterators, and circulators have appropriate
non-mutable counterparts, i.e. \ccc{const_handle},
\ccc{const_iterator}, and \ccc{const_circulator}. The mutable types are
assignable to their non-mutable counterparts.  Both circulators are
assignable to the \ccc{Vertex_iterator}. The iterators are
assignable to the respective handle types. Wherever the handles appear
in function parameter lists, the corresponding iterators can be used as
well.

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Polyhedron}
{
Export template parameter.
}
\ccGlue
\ccNestedType{NT}
{
Number type to represent coordinates.
}
\ccGlue
\ccNestedType{Point_2}
{
2D point that represents (u, v) coordinates computed by parameterization methods. Must provide X() and Y() methods.
}
\ccGlue
\ccNestedType{Point_3}
{
3D point that represents vertices coordinates. Must provide X() and Y() methods.
}
\ccGlue
\ccNestedType{Vector_2}
{
2D vector. Must provide X() and Y() methods.
}
\ccGlue
\ccNestedType{Vector_3}
{
3D vector. Must provide X() and Y() methods.
}
\ccGlue
\ccNestedType{Facet}
{
Opaque type representing a facet of the 3D mesh. No methods are expected.
}
\ccGlue
\ccNestedType{Facet_handle}
{
Handle to a facet. Model of the Handle concept.
}
\ccGlue
\ccNestedType{Facet_const_handle}
{
}
\ccGlue
\ccNestedType{Facet_iterator}
{
Iterator over all mesh facets. Model of the \ccc{ForwardIterator} concept.
}
\ccGlue
\ccNestedType{Facet_const_iterator}
{
}
\ccGlue
\ccNestedType{Vertex}
{
Opaque type representing a vertex of the 3D mesh. No methods are expected.
}
\ccGlue
\ccNestedType{Vertex_handle}
{
Handle to a vertex. Model of the Handle concept.
}
\ccGlue
\ccNestedType{Vertex_const_handle}
{
}
\ccGlue
\ccNestedType{Vertex_iterator}
{
Iterator over all vertices of a mesh. Model of the \ccc{ForwardIterator} concept.
}
\ccGlue
\ccNestedType{Vertex_const_iterator}
{
}
\ccGlue
\ccNestedType{Border_vertex_iterator}
{
Iterator over vertices of the mesh {\em main border}. Model of the \ccc{ForwardIterator} concept.
}
\ccGlue
\ccNestedType{Border_vertex_const_iterator}
{
}
\ccGlue
\ccNestedType{Vertex_around_facet_circulator}
{
Counter-clockwise circulator over a facet's vertices. Model of the \ccc{BidirectionalCirculator} concept.
}
\ccGlue
\ccNestedType{Vertex_around_facet_const_circulator}
{
}
\ccGlue
\ccNestedType{Vertex_around_vertex_circulator}
{
Clockwise circulator over the vertices incident to a vertex. Model of the \ccc{BidirectionalCirculator} concept.
}
\ccGlue
\ccNestedType{Vertex_around_vertex_const_circulator}
{
}
\ccGlue

%END-AUTO(\ccTypes)


\ccCreation
\ccCreationVariable{mesh}  %% define variable name used by \ccMethod below

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Parameterization_polyhedron_adaptor_3(Polyhedron& mesh);}
{
Create an adaptator for an existing \ccc{Polyhedron_3} mesh. The input mesh can be of any genus. It can have have any number of borders. Its {\em main border} will be the mesh's longest border (if there is at least one border).
}
\ccGlue

%END-AUTO(\ccCreation)


\ccOperations

The following methods returning a mutable handle, iterator, or circulator have appropriate
non-mutable counterpart methods, i.e. \ccc{const}, returning a \ccc{const_handle},
\ccc{const_iterator}, or \ccc{const_circulator}.

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\ccMethod{Polyhedron& get_adapted_mesh();}
{
Get the adapted mesh.
}
\ccGlue
\ccMethod{const Polyhedron& get_adapted_mesh() const;}
{
}
\ccGlue
\ccMethod{Polyhedron::Halfedge_const_handle get_halfedge(Vertex_const_handle source, Vertex_const_handle target) const;}
{
Get halfedge from source and target vertices. Will assert if such a halfedge doesn't exist.
}
\ccGlue
\ccMethod{Polyhedron::Halfedge_handle get_halfedge(Vertex_handle source, Vertex_handle target);}
{
}
\ccGlue
\ccMethod{const Halfedge_info* info(Halfedge_const_handle halfedge) const;}
{
Access to additional info attached to halfedges.
}
\ccGlue
\ccMethod{Halfedge_info* info(Halfedge_const_handle halfedge);}
{
}
\ccGlue
\ccMethod{const Vertex_info* info(Vertex_const_handle vertex) const;}
{
Access to additional info attached to vertices.
}
\ccGlue
\ccMethod{Vertex_info* info(Vertex_const_handle vertex);}
{
}
\ccGlue
\ccMethod{bool is_valid() const;}
{
Indicate if the mesh matches the \ccc{ParameterizationMesh_3} concept.
}
\ccGlue
\ccMethod{Vertex_iterator mesh_vertices_begin();}
{
Get iterator over first vertex of mesh.
}
\ccGlue
\ccMethod{Vertex_const_iterator mesh_vertices_begin() const;}
{
}
\ccGlue
\ccMethod{Vertex_iterator mesh_vertices_end();}
{
Get iterator over past-the-end vertex of mesh.
}
\ccGlue
\ccMethod{Vertex_const_iterator mesh_vertices_end() const;}
{
}
\ccGlue
\ccMethod{int count_mesh_vertices() const;}
{
Count the number of vertices of the mesh.
}
\ccGlue
\ccMethod{void index_mesh_vertices();}
{
}
\ccGlue
\ccMethod{Border_vertex_iterator mesh_main_border_vertices_begin();}
{
Get iterator over first vertex of mesh's {\em main border}.
}
\ccGlue
\ccMethod{Border_vertex_const_iterator mesh_main_border_vertices_begin() const;}
{
}
\ccGlue
\ccMethod{Border_vertex_iterator mesh_main_border_vertices_end();}
{
Get iterator over past-the-end vertex of mesh's {\em main border}.
}
\ccGlue
\ccMethod{Border_vertex_const_iterator mesh_main_border_vertices_end() const;}
{
}
\ccGlue
\ccMethod{std::list<Vertex_handle> get_border(Vertex_handle seed_vertex);}
{
Return the border containing \ccc{seed_vertex}. Return an empty list if not found.
}
\ccGlue
\ccMethod{Facet_iterator mesh_facets_begin();}
{
Get iterator over first facet of mesh.
}
\ccGlue
\ccMethod{Facet_const_iterator mesh_facets_begin() const;}
{
}
\ccGlue
\ccMethod{Facet_iterator mesh_facets_end();}
{
Get iterator over past-the-end facet of mesh.
}
\ccGlue
\ccMethod{Facet_const_iterator mesh_facets_end() const;}
{
}
\ccGlue
\ccMethod{int count_mesh_facets() const;}
{
Count the number of facets of the mesh.
}
\ccGlue
\ccMethod{bool is_mesh_triangular() const;}
{
Return true of all mesh's facets are triangles.
}
\ccGlue
\ccMethod{int count_mesh_halfedges() const;}
{
Count the number of halfedges of the mesh.
}
\ccGlue
\ccMethod{Vertex_around_facet_circulator facet_vertices_begin(Facet_handle facet);}
{
Get circulator over facet's vertices.
}
\ccGlue
\ccMethod{Vertex_around_facet_const_circulator facet_vertices_begin(Facet_const_handle facet) const;}
{
}
\ccGlue
\ccMethod{int count_facet_vertices(Facet_const_handle facet) const;}
{
Count the number of vertices of a facet.
}
\ccGlue
\ccMethod{Point_3 get_vertex_position(Vertex_const_handle vertex) const;}
{
Get the 3D position of a vertex.
}
\ccGlue
\ccMethod{Point_2 get_vertex_uv(Vertex_const_handle vertex) const;}
{
Get/set the 2D position (u/v pair) of a vertex. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccGlue
\ccMethod{void set_vertex_uv(Vertex_handle vertex, const Point_2& uv);}
{
}
\ccGlue
\ccMethod{bool is_vertex_parameterized(Vertex_const_handle vertex) const;}
{
Get/set {\em is parameterized} field of vertex. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccGlue
\ccMethod{void set_vertex_parameterized(Vertex_handle vertex, bool parameterized);}
{
}
\ccGlue
\ccMethod{int get_vertex_index(Vertex_const_handle vertex) const;}
{
Get/set vertex index. Default value is undefined. (stored in Polyhedron vertex for debugging purpose).
}
\ccGlue
\ccMethod{void set_vertex_index(Vertex_handle vertex, int index);}
{
}
\ccGlue
\ccMethod{int get_vertex_tag(Vertex_const_handle vertex) const;}
{
Get/set vertex' all purpose tag. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccGlue
\ccMethod{void set_vertex_tag(Vertex_handle vertex, int tag);}
{
}
\ccGlue
\ccMethod{bool is_vertex_on_border(Vertex_const_handle vertex) const;}
{
Return true if a vertex belongs to ANY mesh's border.
}
\ccGlue
\ccMethod{bool is_vertex_on_main_border(Vertex_const_handle vertex) const;}
{
Return true if a vertex belongs to the UNIQUE mesh's main border, i.e. the mesh's LONGEST border.
}
\ccGlue
\ccMethod{Vertex_around_vertex_circulator vertices_around_vertex_begin(Vertex_handle vertex, Vertex_handle start_position = Vertex_handle());}
{
Get circulator over the vertices incident to \ccc{vertex}. \ccc{start_position} defines the optional initial position of the circulator.
}
\ccGlue
\ccMethod{Vertex_around_vertex_const_circulator vertices_around_vertex_begin(Vertex_const_handle vertex, Vertex_const_handle start_position = Vertex_const_handle()) const;}
{
}
\ccGlue
\ccMethod{int get_vertex_seaming(Vertex_const_handle vertex) const;}
{
Get/set vertex seaming flag. Default value is undefined.
}
\ccGlue
\ccMethod{void set_vertex_seaming(Vertex_handle vertex, int seaming);}
{
}
\ccGlue
\ccMethod{int get_halfedge_seaming(Vertex_const_handle source, Vertex_const_handle target) const;}
{
Get/set oriented edge's seaming flag, i.e. position of the oriented edge w.r.t. to the UNIQUE main border.
}
\ccGlue
\ccMethod{void set_halfedge_seaming(Vertex_handle source, Vertex_handle target, int seaming);}
{
}
\ccGlue
\ccMethod{Point_2 get_corners_uv(Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set the 2D position (= (u, v) pair) of corners at the {\em right} of the \ccc{prev_vertex} -$>$ vertex -$>$ \ccc{next_vertex} line. Default value is undefined. (stored in incident halfedges).
}
\ccGlue
\ccMethod{void set_corners_uv(Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, const Point_2& uv);}
{
}
\ccGlue
\ccMethod{bool are_corners_parameterized(Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set {\em is parameterized} field of corners at the {\em right} of the \ccc{prev_vertex} -$>$ vertex -$>$ \ccc{next_vertex} line. Default value is undefined. (stored in incident halfedges).
}
\ccGlue
\ccMethod{void set_corners_parameterized(Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, bool parameterized);}
{
}
\ccGlue
\ccMethod{int get_corners_index(Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set index of corners at the {\em right} of the \ccc{prev_vertex} -$>$ vertex -$>$ \ccc{next_vertex} line. Default value is undefined. (stored in incident halfedges).
}
\ccGlue
\ccMethod{void set_corners_index(Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, int index);}
{
}
\ccGlue
\ccMethod{int get_corners_tag(Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set all purpose tag of corners at the {\em right} of the \ccc{prev_vertex} -$>$ vertex -$>$ \ccc{next_vertex} line. Default value is undefined. (stored in incident halfedges).
}
\ccGlue
\ccMethod{void set_corners_tag(Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, int tag);}
{
}
\ccGlue

%END-AUTO(\ccOperations)


\ccSeeAlso

\ccRefIdfierPage{CGAL::Parameterization_mesh_patch_3<ParameterizationPatchableMesh_3>}  \\


\ccExample

See \ccc{Simple_parameterization.cpp} example.


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

