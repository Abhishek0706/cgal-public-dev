/*!

\page tuto_reconstruction Surface Reconstruction
\cgalAutoToc

\author Simon Giraudot

Surface reconstruction from point clouds is a wide research topic in
geometry processing and can be achieved in many different ways. This
tutorials explains how the different algorithms of \cgal to perform
reconstruction in the most relevant way.

\section TutorialsReconstruction_algorithms Which algorithm should I use?

\cgal \cgalReleaseNumber offers three different algorithms for surface
reconstruction:

- \ref Chapter_Poisson_Surface_Reconstruction "Poisson Surface Reconstruction"
- \ref Chapter_Advancing_Front_Surface_Reconstruction "Advancing Front Surface Reconstruction"
- \ref Chapter_Scale_space_reconstruction "Scale Space Surface Reconstruction"

Choosing one or the other of these methods is strongly dependent on
the input properties and the output requirement. For example, Poisson
always generates closed shapes (surrounding a volume) and requires
normals but does not interpolate input points (the output surface does
not pass exactly through the input points). The following table lists
different properties of the input and output to help you choose which
method is more suited for your work:

<center>
|                                          | Poisson | Advancing front  | Scale space      |
|------------------------------------------|:-------:|:----------------:|:----------------:|
| Are normals required?                    | Yes     | No               | No               |
| Is noise handled?                        | Yes     | By preprocessing | Yes              |
| Is variable sampling handled?            | Yes     | Yes              | By preprocessing |
| Are input points exactly on the surface? | No      | Yes              | Yes              |
| Is the output always closed?             | Yes     | No               | No               |
| Is the output always smooth?             | Yes     | No               | No               |
| Is the output always manifold?           | Yes     | Yes              | Optional         |
| Is the output always orientable?         | Yes     | Yes              | No               |
</center>


\section TutorialsReconstruction_input Reading Input

The reconstruction algorithms on \cgal take a range of iterators on a
container as input and use property maps to access the points (and the
normals if they are needed). Points are typically stored in plain text
format (denoted as 'xyz' format), each point separated by a newline
character and each coordinate separated by a white space. \cgal
provides functions to read such a format:

- `read_xyz_points()`
- `read_xyz_points_and_normals()`

Point may also be stored in an 'off' container, for which we also
provide function:

- `read_off_points()`
- `read_off_points_and_normals()`

Using these functions is pretty straightforward, as can be seen on the
following example:

\code{.cpp}
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/IO/read_xyz_points.h>

#include <vector>
#include <fstream>

// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::Point_3 Point;

int main(int argc, char*argv[])
{
  std::vector<Point> points;

  char* filename = "my_file.xyz";
  std::ifstream stream(filename);
  
  if (!stream ||
      !CGAL::read_xyz_points(stream, std::back_inserter(points)))
  {
    std::cerr << "Error: cannot read file " << filename << std::endl;
    return -1;
  }
  
  std::cout << "Read " << points.size () << " point(s)" << std::endl;
\endcode


\section TutorialsReconstruction_preprocessing Preprocessing

Because reconstruction algorithms have some specific requirements that
point clouds do not always meet, some preprocessing might be necessary
to get the best results.

Note that this _preprocessing_ step is optional: if your input point
cloud is already well shaped, reconstruction may be directly applied
to it.

\subsection TutorialsReconstruction_preprocessing_outliers Outlier removal

Some acquisition techniques generate points that are far away from the
surface have no relevance for reconstruction. They are usually refered
to as 'outliers'. Using the \cgal reconstruction algorithms on
outlier-ridden point clouds produce overly distorted output, it is
therefore strongly advised to filter these outliers _before_
performing reconstruction.

\code{.cpp}
  // Identify outliers
  std::vector<Point>::iterator it
   = CGAL::remove_outliers (points.begin(), points.end(),
                            24, // Number of neighbors considered for evaluation
                            5.0); // Percentage of points to remove

  // Outlier removal function changes the order of the point container
  // and returns an iterator to the first point considered as outlier.
  // These points can either be ignored or removed.
  std::cout << std::distance (points.begin (), it)
	    << " point(s) are inliers." << std::endl;

  points.erase (it, points.end());
\endcode


\subsection TutorialsReconstruction_preprocessing_simplification Simplification

Some laser scanners generate points with widely variable
sampling. Typically, lines of scan are very densely sampled but the
gap between two lines of scan is much larger. This type of input point
cloud might generate badly shaped output for algorithms which, in
general, only accept small variations of sampling density.

\cgal provides several simplification algorithms. In addition to
reducing the size of the input and therefore decreasing computation
time, some of them can help making the input more uniform. This is the
case of the function `grid_simplify_point_set()` which defines a grid
of a user-specified size and only keeps one point per cell.

\code{.cpp}
  // Compute average spacing using neighborhood of 6 points
  double spacing = CGAL::average_spacing (points.begin (), points.end (), 6);

  // Simplify using a grid of size 2 * average spacing
  std::vector<Point>::iterator it
    = CGAL::grid_simplify_point_set (points.begin (), points.end (), 2. * spacing);

  // Simplification functions change the order of the point container
  // and return an iterator to the first point that is not part of the
  // simplified point set. These points can either be ignored or removed.
  std::cout << std::distance (points.begin (), it)
	    << " point(s) remaining after simplification." << std::endl;

  points.erase (it, points.end());
\endcode


\subsection TutorialsReconstruction_preprocessing_smoothing Smoothing

Although reconstructions via 'Poisson' or 'Scale space' handle noise
internally, one may want to get tighter control over the smoothing
step. For example, a slightly noisy point cloud can benefit from some
reliable smoothing algorithms and be reconstructed via 'Advancing
front' which provides interesting output properties (oriented mesh
with boundaries).

Two functions are provided to smooth a noisy point cloud with a good
approximation (i.e. without degrading curvature, for example):

- `jet_smooth_point_set()`
- `bilateral_smooth_point_set()`

These functions directly modify the container:

\code{.cpp}
  // Jet smoothing takes advantage of a larger neighborhood
  CGAL::jet_smooth_point_set (points.begin(), points.end(), 24);
\endcode

\subsection TutorialsReconstruction_preprocessing_normal Normal Estimation

\section TutorialsReconstruction_reconstruction Reconstruction

\section TutorialsReconstruction_postprocessing Postprocessing

\section TutorialsReconstruction_output Writing Output


*/
