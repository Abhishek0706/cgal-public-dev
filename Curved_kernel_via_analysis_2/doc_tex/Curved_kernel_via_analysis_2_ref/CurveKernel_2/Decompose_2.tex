\begin{ccRefFunctionObjectConcept}{CurveKernel_2::Decompose_2}

Collects various curve and curve pair analysis decomposition functions.

\ccDefinition
returns a curve without self-overlapping parts: in case of algebraic curves 
computes a square-free part of supporting polynomial
 
\ccRefines 
\ccc{AdaptableUnaryFunction}  

\ccTypes
\ccThree{typedef CurveKernel_2::CurveAnalysis_2}{argument_type+}{}
\ccTypedef{typedef CurveKernel_2::CurveAnalysis_2 result_type;}{}
\ccGlue
\ccTypedef{typedef CurveKernel_2::CurveAnalysis_2 argument_type;}{}

\ccOperations
\ccCreationVariable{fo}
\ccThree{xxxxxxxxxxx}{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}{}

A model \ccVar\ of this type must provide:

\ccMethod{result_type operator()(const argument_type& p);}{}

\ccSeeAlso
\ccRefIdfierPage{CurveKernel_2::HasFiniteNumberOfSelfIntersections_2}\\

\ccDefinition
computes decomposition of \ccc{CurveAnalysis_2} into a set of non self-overlapping parts, returns the number of pairwise non-overlapping parts. In case of algebraic curves
computes a square-free factorization of a supporting polynomial, returns the number of pairwise coprime square-free factors.

\ccRefines 
\ccc{AdaptableFunctor} with three arguments

\ccTypes
\ccThree{typedef CurveKernel_2::CurveAnalysis_2}{argument_type+}{}
\ccTypedef{typedef std::size_type result_type;}{}
\ccGlue
\ccTypedef{typedef CurveKernel_2::CurveAnalysis_2 first_argument_type;}{}


\ccOperations
\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccThree{result_type}{fo(first_argument_type,++}{}
\ccMethod{template < class OutputIterator1, class OutputIterator2 >
    result_type
    operator()(const first_argument_type& c, OutputIterator1 fit, OutputIterator2 mit);}
{Copies in the output iterator $fit$ pairwise non overlapping parts result from curve decomposition and their respective multiplicities in $mit$. Template argument type of $fit$ is
\ccc{CurveAnalysis_2}, and $mit$ is $int$. Returns the number of computed parts $n$.}

\ccSeeAlso
\ccRefIdfierPage{CurveKernel_2::HasFiniteNumberOfIntersections_2}\\

\ccDefinition
computes for a given pair of curves $ca1$ and $ca2$ their common part $common$ and coprime parts  respectively; returns true if the curves were decomposed.

\ccRefines 
\ccc{AdaptableFunctor} with five arguments 

\ccOperations
\ccCreationVariable{fo}
\ccThree{xxxxxxxxxxx}{xxxxxxxxxxx}{}
A model \ccVar\ of this type must provide:

\ccMethod{< class OutputIterator >
    result_type
    operator()(const CurveKernel_2::CurveAnalysis_2 & ca1, 
               const CurveKernel_2::CurveAnalysis_2 & ca2, 
               OutputIterator oi1, OutputIterator oi2, OutputIterator oib);}
{ Copies in the output iterator $oib$ a common part of $ca1$ and $ca2$ and the respective coprime parts in $oi1$ and $oi2$ as objects of type \ccc{CurveAnalysis_2}.
Returns true if the curves were decomposed.}

\ccSeeAlso
\ccRefIdfierPage{CurveKernel_2::HasFiniteNumberOfIntersections_2}\\


\end{ccRefFunctionObjectConcept}
