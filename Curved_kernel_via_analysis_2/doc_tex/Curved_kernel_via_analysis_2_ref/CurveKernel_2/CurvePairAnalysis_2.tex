\begin{ccRefConcept}{CurvePairAnalysis_2::StatusLine_1}

\ccDefinition

The \ccc{StatusLine_1} concept is meant to provide information
about the intersections of a pair of curves with a vertical line $x = x_0$
for some finite $x_0$, 
ignoring covered vertical lines of the curves themselves.
Each intersection of a 
curve with the status line defined by some given $x$ induces an event. 
An event can be queried for its coordinates (\ccc{Coordinate_2})
and the involved curve(s). 
Note that the involvement also holds for curve ends approaching the 
vertical asymptote. Again \ccc{StatusLine_1} at $x = \pm\infty$ are 
not allowed. 

\ccTypes

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Coordinate_1}{Model of the concept
\ccc{CurveKernel_2::XCoordinate_1}.}

\ccNestedType{Coordinate_2}{Model of the concept
\ccc{CurveKernel_2::XyCoordinate_2}.}
  

\ccCreationVariable{fo}
\ccAccessFunctions

\ccMethod{Coordinate_1 x();}{
  returns the $x$-coordinate of the status line (always a finite value).
}

\ccMethod{size_type number_of_events();}{
  returns number of distinct and finite intersections of a pair of 
  curves with a status line ignoring a real vertical line component 
  of the curves at the given $x$-coordinate.
}

\ccMethod{size_type event_of_curve(size_type k, bool c);}{
  returns the $y$-position of the $k$-th event of the $c$-th
  (0 or 1) curve in the sequence of events. Note that each event
  is formed by the first, the second, or both curves. 
  \ccPrecond{$0 \leq k < \mbox{number of arcs defined for the curve at x()}$}
  The precondition can be checked by queried first the corresponding status
  line of the curve's analysis.
}

\ccMethod{Multiplicity multiplicity_of_intersection(size_type j);}{
  returns the multiplicity of intersection defined at event with position $j$.
  May return $0$ in case multiplicity is unknown.
  \ccPrecond{There is an intersection of both curves at $j$-th event.}
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{std::pair< size_type, size_type > curves_at_event(size_type j);}{
  returns a pair of \ccc{size_type} indicating whether event $j$ is formed by 
  which arc numbers of the first and the second curve, or $-1$, if the 
  corresponding curve is not involved. 
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

Note that this interface mainly rewrites $\{f,g,x\}^n$ in a different way - 
using \ccc{size_type}. Actually the CPVL has to compute this sequence, but for
the interface it is nicer to have it already here to avoid conversion objects
(introducing additional constructor calls, cache-misses, lookup and so on) in
the next layer on top (CK). Obviously, the \ccc{size_type}s
can be computed in a generic
way from a sequence, so that it makes sense to offer a default implementation
providing such conversion. There is no need to document this fact on the 
conceptual view.

\ccMethod{bool is_event();}{
  returns \ccc{true} if a curve has an event or in case there is an 
  intersection of both curves.
}

\ccMethod{bool is_intersection();}{
  returns \ccc{true} if there is an intersection of both curves.
}

\end{ccRefConcept}

\begin{ccRefConcept}{CurveKernel_2::CurvePairAnalysis_2}

\ccDefinition

The \ccc{CurvePairAnalysis_2} concept is meant to provide tools to analyse 
a pair of curves. An analysis is meant to describe the curve pair's 
interesting points and how they are connected. 
The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinate. Each such coordinate is
covered by a \ccc{StatusLine_1}, 
originated by the events of a single curve
and also the intersections of two curves.
These coordinates also define open {\it intervals}
on the $x$-axis. \ccc{StatusLine_1} 
at values in between one such interval
differ only in the values of the \ccc{Coordinate_2} entries. Topological 
information are equal. 

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Coordinate_1}{Model of the concept
\ccc{CurveKernel_2::XCoordinate_1}.}

\ccNestedType{Coordinate_2}{Model of the concept
\ccc{CurveKernel_2::XyCoordinate_2}.}

\ccNestedType{Status_line_1}{Model of the concept
\ccc{CurvePairAnalysis_2::StatusLine_1}.}

\ccNestedType{Curve_analysis_2}{Model of the concept 
\ccc{CurvePairAnalysis::CurveAnalysis_2}.}

\ccCreation
\ccCreationVariable{fo}

\ccConstructor{CurvePairAnalysis_2(Curve_analysis_2 ca1, Curve_analysis_2 ca2);}
{constructs an analysis for the curve-pair defined by analysis given by 
ca1 and ca2. 
\ccPrecond{The polynomials defining the analysis must be squarefree and 
coprime.}
}

\begin{ccAdvanced}

\ccConstructor{template < class InputIterator >
  CurvePairAnalysis_2(Curve_analysis_2 ca1, Curve_analysis_2 ca2, 
  InputIterator begin, InputIterator end);}{
  constructs an analysis for the pair of curves defined by $ca1$ and $ca2$. 
  The iterator range [begin,end) contains factors of $\mbox{resultant}(p,q,y)$,
  i.e., define $x$-coordinates, 
  which allows to simplify the real root isolation within this layer.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_1}.
\ccPrecond{The polynomials defining the analysis must be squarefree and coprime.}
} 
  This constructor has been introduced to enable an upper layer 
(geometric curved kernel) to use additional knowledge on the problem.

\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Curve_analysis_2 curve_analysis(bool c);}{
  returns curve analysis for $c$-''th'' curve (0 or 1)
}

\ccMethod{size_type number_of_status_lines_with_event();}{
  returns number of status lines that encode an event
}


\ccMethod{size_type event_of_curve_analysis(size_type i, bool c);}{
  Given the $i$-th event of the curve pair 
  this method returns the id of the event of the corresponding curve
  analysis $c$ (0 or 1), or $-1$, if the curve has no event at this coordinate.
}

\ccMethod{Status_line status_line_at_event(size_type i);}{
  returns an instance of \ccc{StatusLine_1} at the $i$-th event
  \ccPrecond{$0 \leq i < \mbox{num\_status\_lines\_with\_event()}$}
}

\ccMethod{Status_line status_line_of_interval(size_type i);}{
  returns an instance of \ccc{StatusLine_1} of the $i$-th interval
  between $x$-events.
  \ccPrecond{$0 \leq i leq \mbox{num\_status\_lines\_with\_event()}$}
}

\ccMethod{Status_line status_line_for_x(Coordinate_1 x,
  CGAL::Sign perturb = CGAL::ZERO);}{
  returns status\_line\_at\_event(i), if $x$ hits $i$-th event, otherwise
  returns status\_line\_of\_interval(i), where $i$ is the id of the interval
  $x$ lies in. 
  If $pertub$ is CGAL::NEGATIVE (CGAL::POSITIVE) and $x$ states
  an event, then status\_line\_of\_interval(i) 
  (status\_line\_of\_interval(i+1)) is returned.
  \ccPrecond{$x$ is finite}
}

\ccMethod{Status_line status_line_at_exact_x(Coordinate_1 x);}{
  returns an instance of \ccc{StatusLine_1} at the given $x$
  \ccPrecond{$x$ is finite}
}

Note that the access methods to status lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search some
$x$, or the unique representative status line for an interval). The others 
enable a user to compute status lines for given $x$.

%
%\begin{ccAdvanced}
%
%\ccMethod{Coordinate_2_const_iterator solve_begin();}{
%  returns iterator running over all finite intersection of the two curves.
%}
%
%\ccMethod{Coordinate_2_const_iterator solve_end();}{
%  returns past-end-value for all finite intersections of the two curves.
%}

%\ccMethod{size_type find(Coordinate_2 s);}{
%  returns the index of the event at the status line defined by 
%  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on any curve.
%}

%\end{ccAdvanced}


%Additionally note that we talk about 4 sequences of $x$-critical lines here. 
%
%\begin{itemize}
%\item The sequence of StatusLine\_1 of $p$ where each CVL has been 
%converted and merged with $q$ to a CVPL.
%\item The sequence of StatusLine\_1 of $q$ where each CVL has been 
%converted and merged with $p$ to a CPVL.
%\item The sequence of StatusLine\_1 of the intersections of 
%$p$ and $q$
%\item The merged sequence of StatusLine_1 of the former three 
%sequences. The method event\_id\_of\_x helps to find indexes in the first 
%three sequences starting from an index in this sequence!
%\end{itemize}

\end{ccRefConcept}
