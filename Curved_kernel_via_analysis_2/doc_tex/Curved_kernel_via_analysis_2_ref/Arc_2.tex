% +------------------------------------------------------------------------+
% | Reference manual page: Arc_2.tex
% +------------------------------------------------------------------------+
% | 03.04.2008   Laurent Saboret, Pierre Alliez
% | Package: Curved_kernel_via_analysis_2
% |
\RCSdef{\RCSArcRev}{$Id: header.tex 40270 2007-09-07 15:29:10Z lsaboret $}
\RCSdefDate{\RCSArcDate}{$Date: 2007-09-07 17:29:10 +0200 (Fri, 07 Sep 2007) $}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}[CGAL::internal::]{Arc_2}  %% add template arg's if necessary
\ccRefLabel{Arc_2}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccInclude)

\ccInclude{CGAL/Curved_kernel_via_analysis_2/Arc_2.h}

%END-AUTO(\ccInclude)

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

Class defines an arc on a curve that can be analyzed.

An arc is either non-vertical or vertical. If it is non-vertical, we can assign a constant arc number to its interior and we may can assign (non-identical) arc numbers to its end-points. It depends on whether the arc touches the boundary of the parameter space or not. If it is vertical, no arc number is available.

We distinguish between interior arcs, rays, and branches. An interior arc lies completely in the interior of the parameter space, while a ray has one end that lies on the boundary of the parameter space, and a branch has two end that lie on the boundary.

%END-AUTO(\ccDefinition)

\ccParameters

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$  \\
class \ccc{CurvedKernelViaAnalysis_2},   \\
class \ccc{Rep_}$>$   \\
class \ccc{Arc_2};

%END-AUTO(\ccParameters)

\ccInheritsFrom

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccInheritsFrom)

\ccc{Handle_with_policy}

%END-AUTO(\ccInheritsFrom)

\ccIsModel

\ccTypes

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Curved_kernel_via_analysis_2}
{
this instance's first template parameter
}
\ccGlue
\ccNestedType{Rep}
{
this instance's second template parameter
}
\ccGlue
\ccNestedType{Self}
{
this instance itself
}
\ccGlue
\ccNestedType{Curve_kernel_2}
{
type of curve kernel
}
\ccGlue
\ccNestedType{Coordinate_1}
{
type of an x-coordinate
}
\ccGlue
\ccNestedType{Coordinate_2}
{
type of an xy-coordinate
}
\ccGlue
\ccNestedType{Boundary}
{
type of {\em rational} value in x-range
}
\ccGlue
\ccNestedType{Curve_analysis_2}
{
type of analysis of a pair of curves
}
\ccGlue
\ccNestedType{Curve_pair_analysis_2}
{
type of analysis of a pair of curves
}
\ccGlue
\ccNestedType{Point_2}
{
type of a kernel point
}
\ccGlue
\ccNestedType{Kernel_arc_2}
{
type of kernel arc
}
\ccGlue
\ccNestedType{Base}
{
the handle superclass
}
\ccGlue

%END-AUTO(\ccTypes)

\ccCreation
\ccCreationVariable{a}  %% choose variable name for \ccMethod below

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Arc_2();}
{
Default constructor.
}
\ccGlue
\ccConstructor{Arc_2(const Self& a);}
{
copy constructor
}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c, int arcno, int arcno_p, int arcno_q);}
{
Constructs an arc with two interior end-points (segment).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]first endpoint \item[q]second endpoint \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_p}]The arcnumber wrt c of the arc at p \item[\ccc{arcno_q}]The arcnumber wrt c of the arc at q \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed segment\end{description}
\begin{description}
\item[Precondition:]p.x() != q.x() \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
Constructs an arc with one interior end-point and another end at the left or right boundary of the parameter space (ray I).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point of the ray \item[\ccc{inf_end}]Defining whether the arcs emanates from the left or right boundary \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_o}]The arcnumber wrt c of the arc at origin \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, const Coordinate_1& asympt_x, Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
Constructs a non-vertical arc with one interior end-point and whose other end approaches a vertical asymptote (ray II).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point \item[\ccc{asympt_x}]The x-coordinate of the vertical asymptote \item[\ccc{inf_end}]Arc is approaching the bottom or top boundary \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_o}]The arcnumber wrt c of the arc at origin \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray\end{description}
\begin{description}
\item[Precondition:]origin.x() != \ccc{asympt_x} \end{description}
\ccGlue
\ccConstructor{Arc_2(const Curve_analysis_2& c, int arcno);}
{
Constructs a non-vertical arc with two non-interior ends at the left and right boundary (branch I).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[c]The supporting curve \item[arcno]The arcnumber wrt to c in the interior of the arc \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch \end{description}
\ccGlue
\ccConstructor{Arc_2(const Coordinate_1& asympt_x1, Arr_curve_end inf_end1, const Coordinate_1& asympt_x2, Arr_curve_end inf_end2, const Curve_analysis_2& c, int arcno);}
{
Constructs a non-vertical arc with two ends approaching vertical asymptotes (branch II).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{asympt_x1}]The x-coordinate of the first asymptote \item[\ccc{inf_end1}]Arc is approaching the bottom or top boundary at \ccc{asympt_x1} \item[\ccc{asympt_x2}]The x-coordinate of the second asymptote \item[\ccc{inf_end2}]Arc is approaching the bottom or top boundary at \ccc{asympt_x2} \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch\end{description}
\begin{description}
\item[Precondition:]\ccc{asympt_x1} != \ccc{asympt_x2} \end{description}
\ccGlue
\ccConstructor{Arc_2(Arr_curve_end inf_endx, const Coordinate_1& asympt_x, Arr_curve_end inf_endy, const Curve_analysis_2& c, int arcno);}
{
Construct a non-vertical arc with one left- or right-boundary end and one end that approaches a vertical asymptote (branch III).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{inf_endx}]Defining whether the arc emanates from the left or right boundary \item[\ccc{asympt_x}]The x-coordinate of the asymptote \item[\ccc{inf_endy}]Arc is approaching the bottom or top boundary at \ccc{asympt_x} \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c);}
{
Constructs a vertical arc with two interior end-points (vertical segment).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The first end-point \item[q]The second end-point \item[c]The supporting curve \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed arc\end{description}
\begin{description}
\item[Precondition:]p != q \&\& p.x() == q.x()
c must have a vertical component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, Arr_curve_end inf_end, const Curve_analysis_2& c);}
{
Constructs a vertical arc with one interior end-point and one that reaches the bottom or top boundary (vertical ray).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point \item[\ccc{inf_end}]Ray emanates from bottom or top boundary \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray\end{description}
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const Coordinate_1& x, const Curve_analysis_2& c);}
{
Constructs a vertical arc that connects bottom with top boundary (vertical branch).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-coordinate of the arc \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch\end{description}
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(Rep rep);}
{
[protected] \\
Constructs an arc from a given representation used in rebind.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[rep]Input representation \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed arc \end{description}
\ccGlue
\ccConstructor{Arc_2();}
{
Default constructor.
}
\ccGlue
\ccConstructor{Arc_2(const Self& a);}
{
copy constructor
}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c, int arcno, int arcno_p, int arcno_q);}
{
Constructs an arc with two interior end-points (segment).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]first endpoint \item[q]second endpoint \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_p}]The arcnumber wrt c of the arc at p \item[\ccc{arcno_q}]The arcnumber wrt c of the arc at q \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed segment\end{description}
\begin{description}
\item[Precondition:]p.x() != q.x() \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
Constructs an arc with one interior end-point and another end at the left or right boundary of the parameter space (ray I).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point of the ray \item[\ccc{inf_end}]Defining whether the arcs emanates from the left or right boundary \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_o}]The arcnumber wrt c of the arc at origin \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, const Coordinate_1& asympt_x, Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
Constructs a non-vertical arc with one interior end-point and whose other end approaches a vertical asymptote (ray II).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point \item[\ccc{asympt_x}]The x-coordinate of the vertical asymptote \item[\ccc{inf_end}]Arc is approaching the bottom or top boundary \item[c]The supporting curve \item[arcno]The arcnumber wrt c in the interior of the arc \item[\ccc{arcno_o}]The arcnumber wrt c of the arc at origin \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray\end{description}
\begin{description}
\item[Precondition:]origin.x() != \ccc{asympt_x} \end{description}
\ccGlue
\ccConstructor{Arc_2(const Curve_analysis_2& c, int arcno);}
{
Constructs a non-vertical arc with two non-interior ends at the left and right boundary (branch I).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[c]The supporting curve \item[arcno]The arcnumber wrt to c in the interior of the arc \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch \end{description}
\ccGlue
\ccConstructor{Arc_2(const Coordinate_1& asympt_x1, Arr_curve_end inf_end1, const Coordinate_1& asympt_x2, Arr_curve_end inf_end2, const Curve_analysis_2& c, int arcno);}
{
Constructs a non-vertical arc with two ends approaching vertical asymptotes (branch II).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{asympt_x1}]The x-coordinate of the first asymptote \item[\ccc{inf_end1}]Arc is approaching the bottom or top boundary at \ccc{asympt_x1} \item[\ccc{asympt_x2}]The x-coordinate of the second asymptote \item[\ccc{inf_end2}]Arc is approaching the bottom or top boundary at \ccc{asympt_x2} \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch\end{description}
\begin{description}
\item[Precondition:]\ccc{asympt_x1} != \ccc{asympt_x2} \end{description}
\ccGlue
\ccConstructor{Arc_2(Arr_curve_end inf_endx, const Coordinate_1& asympt_x, Arr_curve_end inf_endy, const Curve_analysis_2& c, int arcno);}
{
Construct a non-vertical arc with one left- or right-boundary end and one end that approaches a vertical asymptote (branch III).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{inf_endx}]Defining whether the arc emanates from the left or right boundary \item[\ccc{asympt_x}]The x-coordinate of the asymptote \item[\ccc{inf_endy}]Arc is approaching the bottom or top boundary at \ccc{asympt_x} \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c);}
{
Constructs a vertical arc with two interior end-points (vertical segment).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The first end-point \item[q]The second end-point \item[c]The supporting curve \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed arc\end{description}
\begin{description}
\item[Precondition:]p != q \&\& p.x() == q.x()
c must have a vertical component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, Arr_curve_end inf_end, const Curve_analysis_2& c);}
{
Constructs a vertical arc with one interior end-point and one that reaches the bottom or top boundary (vertical ray).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[origin]The interior end-point \item[\ccc{inf_end}]Ray emanates from bottom or top boundary \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed ray\end{description}
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const Coordinate_1& x, const Curve_analysis_2& c);}
{
Constructs a vertical arc that connects bottom with top boundary (vertical branch).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-coordinate of the arc \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed branch\end{description}
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(Rep rep);}
{
[protected] \\
Constructs an arc from a given representation used in rebind.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[rep]Input representation \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed arc \end{description}
\ccGlue

%END-AUTO(\ccCreation)

\ccOperations

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\ccMethod{Arr_parameter_space location(Arr_curve_end ce) const;}
{
location of arc's end
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \end{description}
\end{description}
\begin{description}
\item[Returns:]The location of arc's ce in parameterspace \end{description}
\ccGlue
\ccMethod{void set_location(Arr_curve_end ce, Arr_parameter_space loc) const;}
{
Sets boundary type for an end of an arc.
It is supposed that the user thoroughly understands malicious consequences that may result from the misuse of the location
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \item[loc]The location to store \end{description}
\end{description}
\ccGlue
\ccMethod{bool is_finite(Arr_curve_end ce) const;}
{
Is a curve-end finite?
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if finite, false, otherwise \end{description}
\ccGlue
\ccMethod{Point_2 curve_end(Arr_curve_end ce) const;}
{
returns arc's interior curve end
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \end{description}
\end{description}
\begin{description}
\item[Returns:]The minimal point of the arc, or the maximal point of the arc\end{description}
\begin{description}
\item[Precondition:]accessed curve end has finite coordinates \end{description}
\ccGlue
\ccMethod{Coordinate_1 curve_end_x(Arr_curve_end ce) const;}
{
returns x-coordinate of arc's curve end
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \end{description}
\end{description}
\begin{description}
\item[Returns:]x-coordinate of arc's end at ce \end{description}
\begin{description}
\item[Precondition:]accessed curve end has finite x-coordinate \end{description}
\ccGlue
\ccMethod{const Curve_analysis_2& curve() const;}
{
supporting curve of the arc
}
\ccGlue
\begin{description}
\item[Returns:]supporting curve of the arc \end{description}
\ccGlue
\ccMethod{int arcno() const;}
{
arc number in interior
}
\ccGlue
\begin{description}
\item[Returns:]arc number\end{description}
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{int arcno(Arr_curve_end ce) const;}
{
arc number of end of arc, which may be different from arc number in its interior
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce]The intended end \end{description}
\end{description}
\begin{description}
\item[Returns:]Arc number of intended end \end{description}
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{int arcno(const Coordinate_1& x0) const;}
{
arc number at given x-coordinate
If x0 is equal to source's or target's x-coordinate, then the arc number of that point is returned. Otherwise the arc number of the interior is returned.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x0]queried x-coordinate \end{description}
\end{description}
\begin{description}
\item[Returns:]arcnumber at x0 \end{description}
\begin{description}
\item[Precondition:]!\ccc{is_vertical}()
x0 must be within arcs's x-range. \end{description}
\ccGlue
\ccMethod{bool is_vertical() const;}
{
checks if the arc is vertical
}
\ccGlue
\begin{description}
\item[Returns:]true, if vertical, false, otherwise \end{description}
\ccGlue
\ccMethod{const Coordinate_1& x() const;}
{
returns x-coordinate of vertical arc
}
\ccGlue
\begin{description}
\item[Returns:]x-coordinate of line that contains vertical arc \end{description}
\begin{description}
\item[Precondition:]\ccc{is_vertical} \end{description}
\ccGlue
\ccMethod{int interval_id() const;}
{
returns the index of an open interval between two events of the curve the arc belongs to
}
\ccGlue
\begin{description}
\item[Returns:]interval id of supporting curve for this arc \end{description}
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{Boundary boundary_in_x_range_interior() const;}
{
returns boundary value in interior of x-range of non-vertical interval
}
\ccGlue
\begin{description}
\item[Returns:]a rational x-coordinate in the interior of the arc's x-range \end{description}
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{Comparison_result compare_x_near_boundary(Arr_curve_end ce, const Point_2& p) const;}
{
Compare the relative x-positions of an interior point and the arc's end on a bottom or top boundary
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]A reference point; we refer to a vertical line incident to p. \item[ce]\ccc{ARR_MIN_END} if we refer to the arc's minimal end, \ccc{ARR_MAX_END} if we refer to its maximal end. \end{description}
\end{description}
\begin{description}
\item[Returns:]SMALLER if p lies to the left of the arc; LARGER if p lies to the right of the arc; EQUAL in case of an overlap.\end{description}
\begin{description}
\item[Precondition:]the arc's relevant end is on bottom or top boundary \end{description}
\ccGlue
\ccMethod{Comparison_result compare_x_near_boundary(Arr_curve_end ce1, const Kernel_arc_2& cv2, Arr_curve_end ce2) const;}
{
Compare the relative x-positions of the curve end of $\ast$this and cv2.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[ce1]\ccc{ARR_MIN_END} if we refer to this' minimal end, \ccc{ARR_MAX_END} if we refer to this' maximal end. \item[cv2]The second curve. \item[ce2]\ccc{ARR_MIN_END} if we refer to its minimal end, \ccc{ARR_MAX_END} if we refer to its maximal end. \end{description}
\end{description}
\begin{description}
\item[Returns:]SMALLER if this lies to the left of cv2; LARGER if this lies to the right of cv2; EQUAL in case of an overlap.\end{description}
\begin{description}
\item[Precondition:]the curve ends lie on the bottom or top boundary \end{description}
\ccGlue
\ccMethod{Comparison_result compare_y_near_boundary(const Kernel_arc_2& cv2, Arr_curve_end ce) const;}
{
Compare the relative y-positions of two arcs whose ends approach the left or right boundary from the same side.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[ce]\ccc{ARR_MIN_END} if we compare near left boundary \ccc{ARR_MAX_END} if we compare near right boundary \end{description}
\end{description}
\begin{description}
\item[Returns:]SMALLER if this arc lies below cv2; LARGER if this arc lies above cv2; EQUAL in case of an overlap.\end{description}
\begin{description}
\item[Precondition:]The ends are defined on left or right boundary \end{description}
\ccGlue
\ccMethod{Comparison_result compare_y_at_x(const Point_2& p) const;}
{
Compares the relative vertical alignment of a point with this arc.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The point. \end{description}
\end{description}
\begin{description}
\item[Returns:]SMALLER if y(p) $<$ arc(x(p)), i.e. the point is below the arc; LARGER if y(p) $>$ arc(x(p)), i.e. the point is above the arc; EQUAL if p lies on the arc.\end{description}
\begin{description}
\item[Precondition:]p is in the x-range of the arc. \end{description}
\ccGlue
\ccMethod{Comparison_result compare_y_at_x_left(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
Compares the relative vertical aligment of this arc with a second immediately to the left of one of their intersection points.
If one of the curves is vertical (emanating downward from p), it is always considered to be below the other curve.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[p]The intersection point\end{description}
\end{description}
\begin{description}
\item[Returns:]The relative vertical alignment this arc with respect to cv2 immediately to the left of p: SMALLER, LARGER or EQUAL.\end{description}
\begin{description}
\item[Precondition:]The point p lies on both curves, and both of them must be also be defined (lexicographical) to their left. \end{description}
\ccGlue
\ccMethod{Comparison_result compare_y_at_x_right(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
Compares the relative vertical aligment of this arc with a second immediately to the right of one of their intersection points.
If one of the curves is vertical (emanating downward from p), it is always considered to be below the other curve.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[p]The intersection point\end{description}
\end{description}
\begin{description}
\item[Returns:]The relative vertical alignment this arc with respect to cv2 immediately to the right of p: SMALLER, LARGER or EQUAL.\end{description}
\begin{description}
\item[Precondition:]The point p lies on both curves, and both of them must be also be defined (lexicographical) to their right. \end{description}
\ccGlue
\ccMethod{bool is_in_x_range(const Coordinate_1& x, bool * eq_min = NULL, bool * eq_max = NULL) const;}
{
Check if the given x-value is in the x-range of the arc inclusive.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-value. \item[$\ast$\ccc{eq_min}]Output: Is this value equal to the x-coordinate of the \ccc{ARR_MIN_END} point. \item[$\ast$\ccc{eq_max}]Output: Is this value equal to the x-coordinate of the \ccc{ARR_MAX_END} point. \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if p.x() is in x-range of arc, false otherwise \end{description}
\ccGlue
\ccMethod{bool is_in_x_range_interior(const Coordinate_1& x) const;}
{
Checks whether an x-coordinate lies in the interiors of this arc's x-range.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The query coordinate \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if x lies in the interior of this arc's x-range, false otherwise \end{description}
\ccGlue
\ccMethod{bool is_equal(const Kernel_arc_2& cv2) const;}
{
Checks whether a given arc is equal to this one.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The query arc \end{description}
\end{description}
\begin{description}
\item[Returns:]true iff this arc is equal to cv, false otherwise \end{description}
\ccGlue
\ccMethod{bool do_overlap(const Kernel_arc_2& cv2) const;}
{
checks whether this arcs overlaps with another
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The query arc \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if both arcs have infinitely many intersection points, false otherwise \end{description}
\ccGlue
\ccMethod{int multiplicity_of_intersection(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
multiplicity of intersection
The intersection multiplicity of $\ast$this and cv2 at point p is returned.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[p]The intersection point \end{description}
\end{description}
\begin{description}
\item[Returns:]The multiplicity of the intersection at p \end{description}
\begin{description}
\item[Precondition:]p must be an intersection point. \end{description}
\ccGlue
\ccMethod{OutputIterator intersections(const Kernel_arc_2& cv2, OutputIterator oi) const;}
{
Find all intersections of this arc with another one and insert them to the output iterator.
Type of output iterator is Object. It either contains an \ccc{Arc_2} object (overlap) or a \ccc{std::pair<Point_2, unsigned int>} (intersection point + multiplicity). A past-the-end iterator is returned.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[oi]The outputiterator \end{description}
\end{description}
\begin{description}
\item[Returns:]A past-the-end iterator of oi \end{description}
\ccGlue
\ccMethod{bool intersect_right_of_point(const Kernel_arc_2& cv2, const Point_2& p, Point_2& intersection) const;}
{
Computes the next intersection of $\ast$this and cv2 right of p in lexicographical order and returns it through intersection argument.
\ccc{intersect_right_of_point} is not called when using \ccc{sweep_curves}() with intersection dictionary and without validation of internal structures (as is standard). Hence we can be lazy here for the moment without losing performance.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[p]The minimal bound point \item[intersection]The next intersection \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if there is a next intersection and intersection has been set properly, false otherwise \end{description}
\begin{description}
\item[Precondition:]The arcs are not allowed to overlap \end{description}
\ccGlue
\ccMethod{bool intersect_left_of_point(const Kernel_arc_2& cv2, const Point_2& p, Point_2& intersection) const;}
{
Computes the next intersection of $\ast$this and cv2 left of p in lexicographical order and returns it through intersection argument.
\ccc{intersect_right_of_point} is not called when using \ccc{sweep_curves}() with intersection dictionary and without validation of internal structures (as is standard). Hence we can be lazy here for the moment without losing performance.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[p]The maximal bound point \item[intersection]The next intersection \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if there is a next intersection and intersection has been set properly, false otherwise \end{description}
\begin{description}
\item[Precondition:]The arcs are not allowed to overlap \end{description}
\ccGlue
\ccMethod{Kernel_arc_2 trim(const Point_2& p, const Point_2& q) const;}
{
Returns a trimmed version of an arc.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]the new first endpoint \item[q]the new second endpoint \end{description}
\end{description}
\begin{description}
\item[Returns:]The trimmed arc\end{description}
\begin{description}
\item[Precondition:]p != q
both points must be interior and must lie on cv \end{description}
\ccGlue
\ccMethod{void split(const Point_2& p, Kernel_arc_2& s1, Kernel_arc_2& s2) const;}
{
Split an arc at a given point into two sub-arcs.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The split point \item[s1]Output: The left resulting sub-arc (p is its right endpoint) \item[s2]Output: The right resulting sub-arc (p is its left endpoint)\end{description}
\end{description}
\begin{description}
\item[Precondition:]p lies on cv but is not one of its end-points. \end{description}
\ccGlue
\ccMethod{bool are_mergeable(const Kernel_arc_2& cv2) const;}
{
Check whether this arc can be merged with a second.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \end{description}
\end{description}
\begin{description}
\item[Returns:]true if the two arcs are mergeable, i.e., they are supported by the same curve and share a common endpoint; false otherwise. \end{description}
\ccGlue
\ccMethod{Kernel_arc_2 merge(const Kernel_arc_2& cv2) const;}
{
Merges this arc with a second.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \end{description}
\end{description}
\begin{description}
\item[Returns:]The resulting arc\end{description}
\begin{description}
\item[Precondition:]The two arcs are mergeable, that is they are supported by the same curve and share a common endpoint. \end{description}
\ccGlue
\ccMethod{static bool simplify(const Kernel_arc_2& cv, const Coordinate_2& p);}
{
[static] \\
simplifies representation of cv and/or p in case they have non-coprime supporting curves.
}
\ccGlue
\begin{description}
\item[Returns:]true if simplification took place, false otherwise \end{description}
\ccGlue
\ccMethod{static bool simplify(const Kernel_arc_2& cv1, const Kernel_arc_2& cv2);}
{
[static] \\
simplifies representation of cv1 and/or cv2 in case they have non-coprime supporting curves.
}
\ccGlue
\begin{description}
\item[Returns:]true if simplification took place, false otherwise \end{description}
\ccGlue
\ccMethod{Kernel_arc_2 _trim(const Point_2& p, const Point_2& q) const;}
{
[protected] \\
Returns a trimmed version of an arc (internal version that does not use functor).
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]the new first endpoint \item[q]the new second endpoint \end{description}
\end{description}
\begin{description}
\item[Returns:]The trimmed arc\end{description}
\begin{description}
\item[Precondition:]p != q
both points must be interior and must lie on cv \end{description}
\ccGlue
\ccMethod{bool trim_by_arc(const Kernel_arc_2& cv2, Kernel_arc_2& trimmed1, Kernel_arc_2& trimmed2) const;}
{
Trims this arc and cv2 to the common x-range, if it is non-trivial.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]the second arc \item[trimmed1]Output: trimmed version of $\ast$this to joint x-range of $\ast$this and cv2 \item[trimmed1]Output: trimmed version of cv2 to joint x-range of $\ast$this and cv2 \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if $\ast$this and cv2 share a non-trivial common x-range, false otherwise \end{description}
\ccGlue
\ccMethod{void _fix_curve_ends_order();}
{
[protected] \\
function to ensure lexicographical order of the curve ends
must be called once from constructor
}
\ccGlue
\ccMethod{void _check_pt_arcno_and_coprimality(const Point_2& pt, int arcno_on_c, const Curve_analysis_2& c) const;}
{
[protected] \\
establishes preconditions that point pt lies on the curve c with arc number \ccc{arcno_on_c}, also checks that point's supporting curve and c are coprime
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[pt]Given point \item[\ccc{arcno_on_c}]Arcno on curve \item[c]Supporting curve \end{description}
\end{description}
\ccGlue
\ccMethod{void _check_arc_interior() const;}
{
[protected] \\
establishes preconditions to ensure that there are no event points in the arc's interior (only at source and target) and its arc number is constant
}
\ccGlue
\begin{description}
\item[Precondition:]before calling this method source and target must be sorted using \ccc{_fix_curve_ends_order}() \end{description}
\ccGlue
\ccMethod{Comparison_result _compare_arc_numbers(const Kernel_arc_2& cv2, Arr_parameter_space where, Coordinate_1 x0 = Coordinate_1(), Sign perturb = ZERO) const;}
{
[protected] \\
compares y-coordinates of two arcs over an open (or closed) interval or at exact x-coordinate
where specifies whether to compare at negative/positive boundary or at finite point. if where = \ccc{ARR_INTERIOR} perturb defines to compare slightly to the left, on, or to the right of x0
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]the second arc \item[where]the location in parameter space \item[x0]The x-coordinate \item[perturb]determines whether to pertub slightly to the left/right \end{description}
\end{description}
\begin{description}
\item[Returns:]the relative vertical alignment\end{description}
\begin{description}
\item[Precondition:]!\ccc{is_on_bottom_top}(where) \end{description}
\ccGlue
\ccMethod{Comparison_result _compare_coprime(const Kernel_arc_2& cv2, Arr_parameter_space where, Coordinate_1 x0, Sign perturb) const;}
{
[protected] \\
computes vertical ordering of $\ast$this and cv2 having coprime supporting curves
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]the second arc \item[where]the location in parameter space \item[x0]The x-coordinate \item[perturb]determines whether to pertub slightly to the left/right \end{description}
\end{description}
\begin{description}
\item[Returns:]the relative vertical alignment \end{description}
\ccGlue
\ccMethod{Comparison_result _same_arc_compare_xy(const Point_2& p, const Point_2& q, bool equal_x = false, bool only_x = false) const;}
{
[protected] \\
}
\ccGlue
\ccMethod{const Point_2& _minpoint() const;}
{
[protected] \\
min end-point of this arc (provided for code readability)
}
\ccGlue
\begin{description}
\item[Returns:]min endpoint of arc (may lie on a boundary!) \end{description}
\ccGlue
\ccMethod{const Point_2& _maxpoint() const;}
{
[protected] \\
max end-point of this arc (provided for code readability)
}
\ccGlue
\begin{description}
\item[Returns:]max endpoint of arc (may lie on a boundary!) \end{description}
\ccGlue
\ccMethod{int _compute_interval_id() const;}
{
[protected] \\
computes this arc's interval index
}
\ccGlue
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{Boundary _compute_boundary_in_interval() const;}
{
[protected] \\
computes this rational value in the interiors of the arc's x-range
}
\ccGlue
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{std::pair<Kernel_arc_2, Comparison_result> _replace_endpoints(const Point_2& p1, const Point_2& p2, int arcno1 = -1, int arcno2 = -1) const;}
{
[protected] \\
Replaces this arc's end-points by p1 and p2 with arcnos arcno1 and arcno2.
new curve ends are sorted lexicographical in case of need; all preconditions must be checked by the caller
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p1]new first endpoint \item[p2]new second endpoint \item[arcno1]new first arcno (at p1) \item[arcno1]new second arcno (at p2) \end{description}
\end{description}
\begin{description}
\item[Returns:]pair whose first entry represent the refined arc, and whose second entry reports the lexicographic comparison of p1 and p2 \end{description}
\ccGlue
\ccMethod{void _simplify_by(const Curve_pair_analysis_2& cpa_2) const;}
{
[protected] \\
Simplifies representation of the arc !! DEPRECATED FUNCTION !!
Given a decomposition of the arcs's supporting curve into a pair of two curves \ccc{cpa_2}, we search for a curve this arc lies on and reset arc's supporting curve and arcnos appropriately.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{cpa_2}]analysis of curve pair that should be used in simplification \end{description}
\end{description}
\begin{description}
\item[Precondition:]\ccc{cpa_2} must correspond to a decomposition of this arc's supporting curve \end{description}
\ccGlue
\ccMethod{bool _trim_if_overlapped(const Kernel_arc_2& cv2, OutputIterator oi) const;}
{
[protected] \\
returns true if the two arcs $\ast$this and cv2 overlap, overlapping part(s) are inserted to the output iterator oi (of type \ccc{Kernel_arc_2} ); if no overlapping parts found - returns false
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[oi]Report overlapping parts to this output iterator \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if there was an overlap, false otherwise \end{description}
\ccGlue
\ccMethod{static OutputIterator _intersection_points(const Kernel_arc_2& cv1, const Kernel_arc_2& cv2, OutputIterator oi);}
{
[static, protected] \\
computes zero-dimensional intersections of cv1 with cv2.
Intersection points are inserted to the output iterator oi as objects of type \ccc{std::pair<Point_2, unsigned int>} (intersection point + multiplicity)
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv1]the first arc \item[cv2]the second arc \item[oi]reporting zero-dimensional intersections through this output iterator \end{description}
\end{description}
\begin{description}
\item[Precondition:]!cv1.\ccc{do_overlap}() \end{description}
\ccGlue
\ccMethod{static OutputIterator _intersect_at_endpoints(const Kernel_arc_2& cv1, const Kernel_arc_2& cv2, OutputIterator oi);}
{
[static, protected] \\
computes intersection of two arcs meeting only at their curve ends.
Intersection points are returned in the output interator oi as object of type \ccc{std::pair<Point_2, int>} (intersection + multiplicity)
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv1]the first arc \item[cv2]the second arc \item[oi]reporting zero-dimensional intersections through this output iterator \end{description}
\end{description}
\ccGlue
\ccMethod{bool _joint_x_range(const Kernel_arc_2& cv2, Point_2& pt_low, Point_2& pt_high) const;}
{
[protected] \\
computes a joint x-range of two arcs and returns true if arcs' x-ranges overlap; otherwise returns false
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second arc \item[\ccc{pt_low}]Output: Point indicating the lower bound of the the joint x-range \item[\ccc{pt_high}]Output: Point indicating the upper bound of the the joint x-range \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if arcs overlap, false otherwise\end{description}
\begin{description}
\item[Precondition:]both arcs are not vertical \end{description}
\ccGlue
\ccMethod{static OutputIterator _intersect_coprime_support(const Kernel_arc_2& cv1, const Kernel_arc_2& cv2, OutputIterator oi);}
{
[static, protected] \\
computes zero-dimensional intersections of two arcs having coprime supporting curves
intersection points are inserted to the output iterator oi as objects of type \ccc{std::pair<Point_2, unsigned int>} (intersection point + multiplicity)
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv1]the first arc \item[cv2]the second arc \item[oi]reporting zero-dimensional intersections through this output iterator \end{description}
\end{description}
\ccGlue
\ccMethod{void write(std::ostream& os) const;}
{
output operator
write arc to os
}
\ccGlue

%END-AUTO(\ccOperations)

\ccHeading{Friends And Related Functions}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccHeading{Friends And Related Functions})

\ccFunction{std::ostream& operator<<(std::ostream& os, const Arc_2< CurvedKernelViaAnalysis_2, Rep_>& arc);}
{
output operator
writes arc to os
}
\ccGlue

%END-AUTO(\ccHeading{Friends And Related Functions})

%% \ccIncludeExampleCode{Curved_kernel_via_analysis_2/Arc_2.C}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

