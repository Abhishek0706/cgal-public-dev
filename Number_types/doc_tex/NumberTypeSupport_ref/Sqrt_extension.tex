%OPEN: new name for template argument ROOT ?
%But this will cause changes in the interface  i.e. root() should change too.

\begin{ccRefClass}{Sqrt_extension<NT,ROOT>}
\def\ccTagOperatorLayout{\ccFalse}

In addition, \ccc{Sqrt_extension} has another two default template arguments:\\
$\cdot$ \ccc{DifferentExtensionComparable} = \ccc{::CGAL::Tag_false}\\
$\cdot$ \ccc{FilterPredicates} = \ccc{::CGAL::Tag_false}\\
See below for more details. 

\ccDefinition

An instance of this class represents an extension of the type \ccc{NT} by
\textbf{one} square root of the type \ccc{ROOT}. \\ 
\ccc{NT} is required to be constructible from \ccc{ROOT}. \\
\ccc{NT} is required to be an \ccc{IntegralDomainWithoutDivision}. \\
\ccRefName\ is \ccc{RealEmbeddable} if NT is  \ccc{RealEmbeddable}.



For example, let \ccc{Integer} be some type representing $\Z$, then 
\ccc{Sqrt_extension<Integer,Integer>} is able to represent $\Z[\sqrt{root}]$
for some arbitrary Integer  $root$.\footnote{$R[a]$ denotes the 
extension of a ring $R$ by an element $a$. 
See also: \url{http://mathworld.wolfram.com/ExtensionRing.html}}
The value of $root$ is set at 
construction time, or set to zero if it is not specified.

Arithmetic operations among different extensions, say $\Z[\sqrt{a}]$ 
and $\Z[\sqrt{b}]$, are not supported. 
The result would be in $\Z[\sqrt{a},\sqrt{b}]$, which is not 
representable by \ccc{Sqrt_extension<Integer,Integer>}. 
\textbf{The user is responsible to check that arithmetic operations 
are carried out for elements from the same extensions only.}
This is not tested by \ccRefName\ for efficiency reasons. 
A violation of the precondition leads to undefined behavior.
Be aware that for efficiency reasons the given $root$ is stored as it is given to 
the constructor. In particular, an extension by a square root of a square is 
considered as an extension.  


%However, both \ccc{NT} and \ccc{ROOT} can themselves be an instance of
%\ccc{Sqrt_extension}, yielding a nested extension, e.g.,
%\ccc{Sqrt_extension<Sqrt_extension<Integer,Integer>,Integer>} is able to represent 
%$\Z[\sqrt{a}][\sqrt{b}]$ for some integers $a$ and $b$. 



Since elements of \ccRefName\ that lie in different extensions 
are not interoperable with respect to any arithmetic operations, the full
value range of \ccRefName\ does not represent an algebraic structure.
However, each subset of the value range that represents the extension of
NT by a particular square root is a valid algebraic structure, since 
this subset is closed under all provided arithmetic  operations.
From there, \ccRefName\ can be used as if it were a model of an algebraic structure 
concept, with the following correspondence:

\begin{tabular}{ll}
 NT & \ccRefName\  \\
\hline \\
\ccc{IntegralDomainWithoutDivision} & \ccc{IntegralDomainWithoutDivision}\\
\ccc{IntegralDomain}                & \ccc{IntegralDomain}\\
\ccc{UniqueFactorizationDomain}     & \ccc{IntegralDomain}\\
\ccc{EuclideanRing}                 & \ccc{IntegralDomain}\\
\ccc{Field}                         & \ccc{Field}\\
\hline 
\end{tabular}

The extension of a \ccc{UniqueFactorizationDomain} or 
\ccc{EuclideanRing} is just an \ccc{IntegralDomain}, since the extension in general destroys the unique factorization property. For instance consider $\Z[\sqrt{10}]$, the extension of $\Z$ by $\sqrt{10}$: in $\Z[\sqrt{10}]$ the element 10 has two different factorizations $\sqrt{10} \cdot \sqrt{10}$ and  $2 \cdot 5$. In particular, the factorization is not unique. 

%For example take $\Z[\sqrt{10}]$:  \\
%as indicated by \cite{e-eacfcc-03} referring to \cite{hardy-wright,hasse}:
%For the fact that $2$, $5$, and $\sqrt{10}$ are irreducible elements 
%of $\Z[\sqrt{10}]$. It follows immediately that $\Z[\sqrt{10}]$ is not a 
%\ccc{UniqueFactorizationDomain}, 
%because \[10 = \sqrt{10} \cdot \sqrt{10} = 2 \cdot 5\]$ factors in two essentially
%different ways. \\


%However, \ccRefName\ is useful for lengthy computations 
%over one quadratic extension, e.g. it can be used as coefficient type for 
%polynomials, vectors or matrices. In particular it may be preferable to use 
%\ccc{Sqrt_extension} in place of \ccc{leda_real} or \ccc{CORE::Expr}, 
%since it does not suffer from growing expression trees.


If \ccc{NT} is a model of \ccc{RealEmbeddable} the type \ccc{Sqrt_extension} is also considered as \ccc{RealEmbeddable}. However, by default it is not allowed to compare values from different extensions for efficiency reasons. In case such a comparison becomes necessary, use the member function compare with the according Boolean flag. 
If such a comparison is a very frequent case, override the default of \ccc{DifferentExtensionComparable} by giving  \ccc{::CGAL::Tag_true} as third template parameter. This effects the behavior of compare functions as well as the compare operators. 


The fourth template argument, \ccc{FilterPredicates}, triggers an internal filter that may speed up comparisons and sign computations. In case \ccc{FilterPredicates} is set to \ccc{CGAL::Tag_true} the type first computes a double interval containing the represented number and tries to perform the comparison or sign computation using this interval. Once computed, this interval is stored by the corresponding \ccc{Sqrt_extension} object for further usage. Note that this internal filter is switched off by default, since it may conflict with other filtering methods, such as \ccc{CGAL::Lazy_exact_nt<Sqrt_extension>}. 

In case \ccc{NT} is not \ccc{RealEmbeddable}, \ccc{DifferentExtensionComparable} as well as \ccc{FilterPredicates} have no effect. 

\ccIsModel 
\begin{tabular}{ll}
\ccc{Assignable}\\
\ccc{CopyConstructible}\\
\ccc{DefaultConstructible}\\
\ccc{EqualityComparable}\\
\ccc{ImplicitInteroperable} & with int\\
\ccc{ImplicitInteroperable} & with NT\\
\ccc{Fraction}          & if NT is a \ccc{Fraction}\\
\ccc{RootOf_2}&\\
\end{tabular}


%\begin{ccAdvanced}
%\ccc{Sqrt_extension} is \ccc{Modularizable} in case \ccc{NT} is 
%\ccc{Modularizable}.
%\end{ccAdvanced}

\ccCreation
\ccTwo{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}{}
\ccCreationVariable{ext}
\ccConstructor{Sqrt_extension ();} 
        {Introduces an variable initialized with 0.} \ccGlue
\ccConstructor{Sqrt_extension (const Sqrt_extension& x);}
 	{Copy constructor.}\ccGlue
\ccConstructor{Sqrt_extension (const int &i);}
        {Introduces an variable initialized with $i$.}\ccGlue
\ccConstructor{Sqrt_extension (const NT &x);}
        {Introduces an variable initialized with $x$.}
\ccConstructor{Sqrt_extension (int a0, int a1, int r);}
 	{Constructor from int: \ccVar $= a0 +a1 \cdot sqrt(r)$. \ccPrecond{$r \neq 0$}}\ccGlue
\ccConstructor{Sqrt_extension (NT a0, NT a1, ROOT r);}
 	{General constructor: \ccVar $= a0 + a1 \cdot sqrt(r)$. \ccPrecond{$r \neq 0$}}

\ccOperations

An object of type \ccc{Sqrt_extension} represent an expression of the form: 
$a0 + a1 * sqrt(root)$. 

\ccMethod{const NT & a0 () const ;    }{Const access operator for a0} \ccGlue
\ccMethod{const NT & a1 () const ;    }{Const access operator for a1}\ccGlue
\ccMethod{const ROOT & 	root () const;}{Const access operator for root}\ccGlue

%\ccMethod{void 	number (NT& a0, NT& a1, ROOT& root) const;}
%{Simultaneous access to all relevant members.}

\ccMethod{bool is_extended () const;}
 	{Returns true in case root of \ccVar\ is not zero.  \\
         Note that $a1 == 0 $ does not imply $root == 0$. }   

%Member functions:\\
\ccMethod{void 	simplify ();}
        { Simplifies the representation, in particular $root$ is set to 
          zero if $a1$ is zero, that is, \ccVar\ becomes not extended.\\
          Moreover, it propagates the simplify command to members
          %, that is $a0$, $a1$ and $root$, 
          of \ccVar. see also: \ccc{AlgebraicStructureTraits::Simplify}.     
        }
\ccMethod{bool 	is_zero () const;}
        {returns true if \ccVar\ represents the value zero.}

\ccMethod{CGAL::Sign sign () const;}
        {Determines the sign of \ccVar\ by (repeated) squaring.
        \ccPrecond \ccc{Sqrt_extension} is \ccc{RealEmbeddable}.}

\ccMethod{Sqrt_extension abs () const;}
 	{returns the absolute value of \ccVar. 
        \ccPrecond \ccc{Sqrt_extension} is \ccc{RealEmbeddable}.}

\ccMethod{
CGAL::Comparison_result compare 
(const Sqrt_extension& y, bool in_same_extension = !DifferentExtensionComparable::value) const;}{
  Compares \ccVar\ with y. \\
  The optional bool \ccc{in_same_extension} indicates whether \ccVar\ 
  and $y$ are in the same extension of NT.
}


\ccFunction{Sqrt_extension operator+(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{Sqrt_extension operator-(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{Sqrt_extension operator*(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue


\ccMethod{Sqrt_extension & operator+=(const Sqrt_extension& a);}
{\ccPrecond \ccc{(this->root()==0 or a.root()==0 or this->root() == a.root())} }\ccGlue

\ccMethod{Sqrt_extension & operator-=(const Sqrt_extension& a);}
{\ccPrecond \ccc{(this->root()==0 or a.root()==0 or this->root() == a.root())} }\ccGlue

\ccMethod{Sqrt_extension & operator*=(const Sqrt_extension& a);}
{\ccPrecond \ccc{(this->root()==0 or a.root()==0 or this->root() == a.root())} }\ccGlue

In case \ccc{NT} is only an \ccc{IntegralDomain} operator/ implements integral division. 
In case \ccc{NT} is a \ccc{Field} operator/ implements the field division.    

\ccFunction{Sqrt_extension operator/(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccMethod{Sqrt_extension & operator/=(const Sqrt_extension& a);}
{\ccPrecond \ccc{(this->root()==0 or a.root()==0 or this->root() == a.root())} }\ccGlue
\ccFunction{bool operator==(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{bool operator!=(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue

In case  \ccc{Sqrt_extension} is \ccc{RealEmbeddable}:

\ccFunction{bool operator< (const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{bool operator<=(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{bool operator> (const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue
\ccFunction{bool operator>=(const Sqrt_extension&a,const Sqrt_extension& b);}
{\ccPrecond \ccc{(a.root()==0 or b.root()==0 or a.root() == b.root())} }\ccGlue



\ccIgnore{ 
% Mixed operations with NT (don't forget int in case you want to re add them)
\ccFunction{Sqrt_extension operator+(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator-(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator*(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator+(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator-(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator*(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccMethod{Sqrt_extension & 	operator += (const NT &a);}{}\ccGlue
\ccMethod{Sqrt_extension & 	operator -= (const NT &a);}{}\ccGlue
\ccMethod{Sqrt_extension & 	operator *= (const NT &a);}{}\ccGlue
\ccFunction{Sqrt_extension operator/(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{Sqrt_extension operator/(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccMethod{Sqrt_extension & 	operator /= (const NT &a);}{}
\ccFunction{bool operator==(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{bool operator!=(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{bool operator==(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{bool operator!=(const Sqrt_extension&a, const NT &b);}{}
\ccFunction{bool operator< (const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{bool operator<=(const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{bool operator> (const NT&a, const Sqrt_extension &b);}{}\ccGlue
\ccFunction{bool operator>=(const NT&a, const Sqrt_extension &b);}{}
\ccFunction{bool operator< (const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{bool operator<=(const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{bool operator> (const Sqrt_extension&a, const NT &b);}{}\ccGlue
\ccFunction{bool operator>=(const Sqrt_extension&a, const NT &b);}{}
}

The stream operations are available as well. 
They assume that corresponding stream operators for type \ccc{NT} and \ccc{ROOT} exist.

\ccFunction{std::ostream& operator<<(std::ostream& os, const Sqrt_extension<NT,ROOT> &ext);}
{writes \ccc{ext} to ostream \ccc{os}. The format depends on the \ccc{CGAL::IO::MODE} of \ccc{os}.\\
        In case the mode is \ccc{CGAL::IO::ASCII} the format is {\tt EXT[a0,a1,root]}. \\
        In case the mode is \ccc{CGAL::IO::PRETTY} the format is human readable. \\
        }

\ccFunction{std::istream& operator>>(std::istream& is, const Sqrt_extension<NT,ROOT> &ext);}
{reads \ccc{ext} from istream \ccc{is} in format {\tt EXT[a0,a1,root]}, the output format in mode \ccc{CGAL::IO::ASCII} }



%void 	output_maple (std::ostream &os) const
% 	write Sqrt_extension to os in LiS::IO::PRETTY format
%void 	output_ascii (std::ostream &os) const
% 	write Sqrt_extension to os in a format readable by input_ascii()
\ccSeeAlso


\ccRefIdfierPage{IntegralDomainWithoutDivision}\\
\ccRefIdfierPage{IntegralDomain}\\
\ccRefIdfierPage{Field}\\
\ccRefIdfierPage{RealEmbeddable}\\
\ccRefIdfierPage{ImplicitInteroperable}\\
\ccRefIdfierPage{Fraction}\\
\ccRefIdfierPage{RootOf_2}\\

\ccRefIdfierPage{CGAL::Tag_true}\\
\ccRefIdfierPage{CGAL::Tag_false}\\

\end{ccRefClass}
