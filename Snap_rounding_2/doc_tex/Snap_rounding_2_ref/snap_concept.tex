% | Reference manual page: SnapRoundingTraits_2.tex
% | Package: Snap_rounding_2

\ccRefPageBegin
\begin{ccRefConcept}{SnapRoundingTraits_2}

\ccDefinition
% ===========
The concept \ccRefName{} lists the set of requirements that must be fulfilled
by an instance of the \ccc{Traits} template-parameter of the free function
\ccc{snap_rounding_2<Traits,InputIterator,OutputContainer>()}. The list
includes the nested types of the geometric primitives used in this class and
some function object types for the required predicates on those primitives.

\ccRefines
% ========
\ccc{ArrangementTraits_2}

\ccTypes
% ======
\ccNestedType{FT}{The number type. This type must fulfill the requirements on
\ccc{FieldNumberType}}
\ccGlue
\ccNestedType{Point_2}{Models the concept \ccc{ArrTraits::Point_2}.}
\ccGlue
\ccNestedType{Segment_2}{Models the concept
  \ccc{ArrTraits::XMonotoneCurve_2}.}
\ccGlue
\ccNestedType{Iso_rectangle_2}{Models the concept
  \ccc{SRTraits_2::IsoRectangle_2}.}

\ccHeading{Functor Types}
% =======================
\ccThree{Construct_iso_rectangle_2}{}{\hspace*{14cm}}
\ccThreeToTwo

\ccNestedType{Construct_vertex_2}{Models the concept
  \ccc{SRTraits_2::ConstructVertex_2}.}
\ccGlue
\ccNestedType{Construct_segment_2}{Models the concept
  \ccc{SRTraits_2::ConstructSegment_2}.}
\ccGlue
\ccNestedType{Construct_iso_rectangle_2}{Models the concept
  \ccc{SRTraits_2::ConstructIsoRectangle_2}.}

\ccNestedType{To_double}{Models the concept
  \ccc{RealEmbeddableTraits::ToDouble}. The precision of this operation is
  of not high significance, as it is only used in the implementation of the
  heuristic technique to exploit a cluster of kd-trees rather than just one.}
\ccGlue
\ccNestedType{Compare_x_2}{Models the concept \ccc{SRTraits_2::CompareX_2}.}
\ccGlue
\ccNestedType{Compare_y_2}{Models the concept \ccc{SRTraits_2::CompareY_2}.}
\ccGlue
\ccNestedType{Snap_2}{Models the concept \ccc{SRTraits_2::Snap_2}.}

\ccNestedType{Integer_grid_point_2}{Models the concept
  \ccc{SRTraits_2::IntegerGridPoint_2}.}

\ccNestedType{Minkowski_sum_with_pixel_2}{Models the concept
  \ccc{SRTraits:MinkowskiSumWithPixel_2}.}

% \ccCreation
% =========
\ccCreationVariable{traits}  %% choose variable name

\ccHeading{Accessing Functor Objects}
% ===================================
\ccThree{Minkowski_sum_with_pixel_2}{minkowski_sum_with_pixel_2_object() const;}{}
\ccMethod{Construct_vertex_2 construct_vertex_2_object() const;}{}
\ccGlue
\ccMethod{Construct_segment_2 construct_segment_2_object() const;}{}
\ccGlue
\ccMethod{Construct_iso_rectangle_2 construct_iso_rectangle_2_object() const;}{}

\ccMethod{Compare_x_2 compare_x_2_object() const;}{}
\ccGlue
\ccMethod{Compare_y_2 compare_y_2_object() const;}{}
\ccGlue
\ccMethod{Snap_2 snap_2_object() const;}{}
\ccGlue
\ccMethod{Integer_grid_point_2 integer_grid_point_2_object() const;}{}
\ccGlue
\ccMethod{Minkowski_sum_with_pixel_2 minkowski_sum_with_pixel_2_object() const;}{}

\ccHasModels
% ==========
\ccc{CGAL::Snap_rounding_traits<Kernel>}

\ccSeeAlso
% ========
\ccc{CGAL::Snap_rounding_2<Traits>}

\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Geometric Objects %%%%%%%%
% =================================

%%%%%%%% IsoRectangle_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::IsoRectangle_2}
\ccDefinition
Represents an iso rectangle.

\ccRefines{DefaultConstructible, CopyConstructible, Assignable}

\ccHasModels\ccc{SRTraits_2::Iso_rectangle_2}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Functors %%%%%%%%
% ========================
%%%%%%%% ConstructVertex_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::ConstructVertex_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{SRTraits_2::Construct_vertex_2}

\ccCreationVariable{fo}

\ccMethod{Point_2 operator()(Segment_2 seg, int i);}{%
  returns the source or target of \ccc{seg}. If \ccc{i} modulo $2$ is $0$,
  the source is returned, otherwise the target is returned.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% ConstructSegment_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::ConstructSegment_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{SRTraits_2::Construct_segment_2}

\ccCreationVariable{fo}

\ccMethod{Segment_2 operator()(Point_2 p, Point_2 q);}{%
  introduces a segment with source \ccc{p} and target \ccc{q}. The segment
  is directed from the source towards the target.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% ConstructIsoRectangle_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::ConstructIsoRectangle_2}
\ccRefines{AdaptableQuaternaryFunction}

\ccHasModels\ccc{SRTraits_2::Construct_iso_rectangle_2}

\ccCreationVariable{fo}

\ccMethod{Iso_rectangle_2 operator()(Point_2 left, Point_2 right,
                                     Point_2 bottom, Point_2 top);}{%
  introduces an iso-oriented rectangle fo whose minimal $x$ coordinate
  is the one of \ccc{left}, the maximal $x$ coordinate is the one of
  \ccc{right}, the minimal $y$ coordinate is the one of \ccc{bottom},
  the maximal $y$ coordinate is the one of \ccc{top}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareX_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::CompareX_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{SRTraits_2::Compare_x_2}

\ccCreationVariable{fo}

\ccMethod{Comparison_result operator()(Point_2 p, Point_2 q);}{%
  returns \ccc{SMALLER, EQUAL}, or \ccc{LARGER} according to the $x$-ordering
  of the points \ccc{p} and \ccc{q}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareY_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::CompareY_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{SRTraits_2::Compare_y_2}

\ccCreationVariable{fo}

\ccMethod{Comparison_result operator()(Point_2 p, Point_2 q);}{%
  returns \ccc{SMALLER, EQUAL}, or \ccc{LARGER} according to the $y$-ordering
  of the points \ccc{p} and \ccc{q}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Snap_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::Snap_2}
\ccRefines{AdaptableQuaternaryFunction}

\ccHasModels\ccc{SRTraits_2::Snap_2}

\ccCreationVariable{fo}

\ccMethod{void operator()(Point_2 p, FT pixel_size, FT &x, FT &y);}{%
  rounds a point to a center of a pixel (unit square) in the grid used by
  the Snap Rounding algorithm. Note that no conversion to an integer grid
  is done yet. $p$ is the input point, \ccc{pixel_size} is the size of the
  pixel of the grid, and $x$ and $y$ are the $x$ and $y$-coordinates of
  the rounded point respectively.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% IntegerGridPoint_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::IntegerGridPoint_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{SRTraits_2::Integer_grid_point_2}

\ccCreationVariable{fo}

\ccMethod{Point_2 operator()(Point_2 p, NT pixel_size);}{%
  converts coordinates into an integer representation where one unit is equal
  to pixel size. For instance, if a point has the coordinates $(3.7,5.3)$
  and the pixel size is $0.5$, then the new point will have the coordinates
  of $(7,10)$. Note, however, that the number type remains the same here,
  although integers are represented. $p$ is the converted point and
  \ccc{pixel_size} is the size of the pixel of the grid.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% MinkowskiSumWithPixel_2
\ccRefPageBegin
\begin{ccRefConcept}{SRTraits_2::MinkowskiSumWithPixel_2}
\ccRefines{AdaptableTernaryFunction}

\ccHasModels\ccc{SRTraits_2::Minkowski_sum_with_pixel_2}

\ccCreationVariable{fo}

\ccMethod{void operator()(std::list<Point_2>& vertices_list, Segment_2 s,
                          NT unit_square);}{%
  returns the vertices of a polygon, which is the Minkowski sum of a segment
  and a square centered at the origin with edge size \ccc{pixel edge}.
  \ccc{vertices_list} is the list of the vertices of the Minkowski sum
  polygon, $s$ is the input segment and \ccc{unit_square} is the edge
  size of the pixel.}
\end{ccRefConcept}
\ccRefPageEnd
