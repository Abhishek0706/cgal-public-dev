% Reference manual page: ArrangementBasicTraits.tex
% Package: Arrangement_2

\ccRefPageBegin
\begin{ccRefConcept}{ArrangementBasicTraits_2}

\ccDefinition
% ===========
The concept \ccRefName{} defines the minimal set of geometric
predicates needed for the construction and maintenance of objects of the
class \ccc{Arrangement_2}, as well as performing simple queries (such as
point-location queries) on such arrangements.

A model of this concept must define nested \ccc{Point_2} and
\ccc{X_monotone_curve_2} types, which represent planar points and
continuous $x$-monotone curves (a vertical segment is also considered to be
{\sl weakly} $x$-monotone), respectively. The $x$-monotone curves are assumed
to be pairwise disjoint in their interiors, so they do not intersect
except at their endpoints.

The \ccc{X_monotone_curve_2} curves of an arrangement are confined to an
iso-rectangular area called the parameter space. The iso-rectangule can
be unbounded, open, or closed. The set of predicates provided by a model
the concept \ccRefName{} is sufficient for constructing arrangements of
$x$-monotone curves that do not reach or approach the boundary of the
parameter space. The nature of the input curves, whether they are
expected to reach or approach the left, right, bottom, or top side of the
boundary of the parameter space, are conveyed through the definition of
four additional nested types, namely \ccc{Left_side_category},
\ccc{Right_side_category}, \ccc{Bottom_side_category}, and
\ccc{Top_side_category}. Each such type must be convertible to the type
\ccc{Arr_oblivious_side_tag}.

\ccRefines{DefaultConstructible, CopyConstructible, Assignable}

\ccTypes
% ======
\ccNestedType{Point_2}{models the concept \ccc{ArrTraits::Point_2}.}
\ccGlue
\ccNestedType{X_monotone_curve_2}
  {models the concept \ccc{ArrTraits::XMonotoneCurve_2}.}

\ccHeading{Categories}
% ==============
\ccNestedType{Has_left_category}
  {indicates whether the nested functor \ccc{Compare_at_x_left_2} is
  provided. It must be convertible to \ccc{Tag_true} or \ccc{Tag_false}.} 

\ccNestedType{Left_side_category}
  {Must be convertible to \ccc{Arr_oblivious_side_tag}.}
\ccNestedType{Bottom_side_category}
  {Must be convertible to \ccc{Arr_oblivious_side_tag}.}
\ccNestedType{Top_side_category}
  {Must be convertible to \ccc{Arr_oblivious_side_tag}.}
\ccNestedType{Right_side_category}
  {Must be convertible to \ccc{Arr_oblivious_side_tag}.}

\ccHeading{Functor Types}
% =======================
\ccThree{Compare_y_at_x_2}{}{\hspace*{14cm}}
\ccThreeToTwo
\ccNestedType{Compare_x_2}{models the concept \ccc{ArrTraits::CompareX_2}.}
\ccGlue
\ccNestedType{Compare_xy_2}{models the concept \ccc{ArrTraits::CompareXy_2}.}
\ccGlue
\ccNestedType{Construct_min_vertex_2}
  {models the concept \ccc{ArrTraits::ConstructMinVertex_2}.}
\ccGlue
\ccNestedType{Construct_max_vertex_2}
  {models the concept \ccc{ArrTraits::ConstructMaxVertex_2}.}
\ccGlue
\ccNestedType{Is_vertical_2}{models the concept \ccc{ArrTraits::IsVertical_2}.}
\ccGlue
\ccNestedType{Compare_y_at_x_2}
  {models the concept \ccc{ArrTraits::CompareYAtX_2}.}
\ccGlue
\ccNestedType{Compare_y_at_x_left_2}
  {models the concept \ccc{ArrTraits::CompareYAtXLeft_2}.
  Required only if the \ccc{Has_left_category} category is convertible to
  \ccc{Tag_true}.}
\ccGlue
\ccNestedType{Compare_y_at_x_right_2}
  {models the concept \ccc{ArrTraits::CompareYAtXRight_2}.}
\ccGlue
\ccNestedType{Equal_2}{models the concept \ccc{ArrTraits::Equal_2}.}

% \ccCreation
\ccCreationVariable{traits}
% =========================

\ccHeading{Accessing Functor Objects}
% ===================================
\ccThree{Compare_y_at_x_right_2~~~}{}{\hspace*{14cm}}
\ccThreeToTwo
\ccMethod{Compare_x_2 compare_x_2_object() const;} {}
\ccGlue
\ccMethod{Compare_xy_2 compare_xy_2_object() const;} {}
\ccGlue
\ccMethod{Construct_min_vertex_2 construct_min_vertex_2_object() const;} {}
\ccGlue
\ccMethod{Construct_max_vertex_2 construct_max_vertex_2_object() const;} {}
\ccGlue
\ccMethod{Is_vertical_2 is_vertical_2_object() const;} {}
\ccGlue
\ccMethod{Compare_y_at_x_2 compare_y_at_x_2_object() const;} {}
\ccGlue
\ccMethod{Compare_y_at_x_left_2 compare_y_at_x_left_2_object() const;} {}
\ccGlue
\ccMethod{Compare_y_at_x_right_2 compare_y_at_x_right_2_object() const;} {}
\ccGlue
\ccMethod{Equal_2 equal_2_object() const;} {}

\ccHasModels
% ==========
\ccc{CGAL::Arr_segment_traits_2<Kernel>}\\
\ccc{CGAL::Arr_non_caching_segment_basic_traits_2<Kernel>}\\
\ccc{CGAL::Arr_non_caching_segment_traits_2<Kernel>}\\
\ccc{CGAL::Arr_linear_traits_2<Kernel>}\\
\ccc{CGAL::Arr_polyline_traits_2<SegmentTraits>}\\
\ccc{CGAL::Arr_circle_segment_traits_2<Kernel>}\\
\ccc{CGAL::Arr_line_arc_traits_2<CircularKernel>}\\
\ccc{CGAL::Arr_circular_arc_traits_2<CircularKernel>}\\
\ccc{CGAL::Arr_circular_line_arc_traits_2<CircularKernel>}\\
\ccc{CGAL::Arr_conic_traits_2<RatKernel,AlgKernel,NtTraits>}\\
\ccc{CGAL::Arr_rational_arc_traits_2<AlgKernel,NtTraits>}\\
\ccc{CGAL::Arr_Bezier_curve_traits_2<RatKernel,AlgKernel,NtTraits>}\\
\ccc{CGAL::Arr_algebraic_segment_traits_2<Coefficient>}\\
\ccc{CGAL::Arr_curve_data_traits_2<Tr,XData,Mrg,CData,Cnv>}\\
\ccc{CGAL::Arr_consolidated_curve_data_traits_2<Traits,Data>}

\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Geometric Objects %%%%%%%%
% =================================

%%%%%%%% Point_2
% ==============
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::Point_2}
\ccDefinition
Represents a point in the plane.

\ccRefines{DefaultConstructible, CopyConstructible, Assignable}

\ccHasModels\ccc{ArrangementBasicTraits_2::Point_2}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% XMonotoneCurve_2
% =======================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::XMonotoneCurve_2}
\ccDefinition
Represents a planar (weakly) $x$-monotone curve.

\ccRefines{DefaultConstructible, CopyConstructible, Assignable}

\ccHasModels\ccc{ArrangementBasicTraits_2::X_monotone_curve_2}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Functors %%%%%%%%
% ========================

%%%%%%%% CompareX_2
% =================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::CompareX_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Compare_x_2}

\ccCreationVariable{fo}
\ccMethod{Comparison_result operator()(ArrTraits::Point_2 p1,
                                       ArrTraits::Point_2 p2);}
  {returns \ccc{SMALLER}, \ccc{EQUAL}, or \ccc{LARGER}
  according to the $x$-ordering of points \ccc{p1} and \ccc{p2}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareXy_2
% ==================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::CompareXy_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Compare_xy_2}

\ccCreationVariable{fo}
\ccMethod{Comparison_result operator()(ArrTraits::Point_2 p1,
                                       ArrTraits::Point_2 p2);}
  {returns \ccc{SMALLER}, \ccc{EQUAL}, or \ccc{LARGER} according 
  to the lexicographic $xy$-order of the points \ccc{p1} and \ccc{p2}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% ConstructMinVertex_2
% ===========================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::ConstructMinVertex_2}
\ccRefines{AdaptableUnaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Construct_min_vertex_2}

\ccCreationVariable{fo}
\ccMethod{ArrTraits::Point_2 operator()(ArrTraits::X_monotone_curve_2 xc);}
  {returns the lexicographically smaller (left) endpoint of \ccc{xc}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% ConstructMaxVertex_2
% ===========================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::ConstructMaxVertex_2}
\ccRefines{AdaptableUnaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Construct_max_vertex_2}

\ccCreationVariable{fo}
\ccMethod{ArrTraits::Point_2 operator()(ArrTraits::X_monotone_curve_2 xc);}
  {returns the lexicographically larger (right) endpoint of \ccc{xc}.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% IsVertical_2
% ===================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::IsVertical_2}
\ccRefines{AdaptableUnaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Is_vertical_2}

\ccCreationVariable{fo}
\ccMethod{bool operator()(ArrTraits::X_monotone_curve_2 xc);}
  {determines whether \ccc{xc} is a vertical segment.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareYAtX_2
% ====================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::CompareYAtX_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Compare_y_at_x_2}

\ccCreationVariable{fo}
\ccMethod{Comparison_result operator()(ArrTraits::Point_2 p,
                                       ArrTraits::X_monotone_curve_2 xc);}
  {compares the $y$-coordinates of \ccc{p} and the vertical 
  projection of \ccc{p} on \ccc{xc}, and returns \ccc{SMALLER}, \ccc{EQUAL},
  or \ccc{LARGER} according to the result.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareYAtXLeft_2
% ========================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::CompareYAtXLeft_2}
\ccRefines{AdaptableTernaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Compare_y_at_x_left_2}

\ccCreationVariable{fo}
\ccMethod{Comparison_result operator()(ArrTraits::X_monotone_curve_2 xc1,
                                       ArrTraits::X_monotone_curve_2 xc2,
                                       ArrTraits::Point_2 p);}
  {accepts two $x$-monotone curves \ccc{xc1} and \ccc{xc2}
  that have a common right endpoint \ccc{p}, and returns \ccc{SMALLER,
  EQUAL} or \ccc{LARGER} according to the relative position of the two
  curves immediately to the left of $p$. Note that in case one of the
  $x$-monotone curves is a vertical segment (emanating downward from
  \ccc{p}), it is always considered to be {\sl below} the other curve.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% CompareYAtXRight_2
% =========================
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::CompareYAtXRight_2}
\ccRefines{AdaptableTernaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Compare_y_at_x_right_2}

\ccCreationVariable{fo}
\ccMethod{Comparison_result operator()(ArrTraits::X_monotone_curve_2 xc1,
                                       ArrTraits::X_monotone_curve_2 xc2,
                                       ArrTraits::Point_2 p);}
  {accepts two $x$-monotone curves \ccc{xc1} and \ccc{xc2}
  that have a common left endpoint \ccc{p}, and returns \ccc{SMALLER,
  EQUAL} or \ccc{LARGER} according to the relative position of the two
  curves immediately to the right of $p$. Note that in case one of the
  $x$-monotone curves is a vertical segment emanating upward from
  \ccc{p}, it is always considered to be {\sl above} the other curve.}
\end{ccRefConcept}
\ccRefPageEnd

%%%%%%%% Equal_2
% ==============
\ccRefPageBegin
\begin{ccRefConcept}{ArrTraits::Equal_2}
\ccRefines{AdaptableBinaryFunction}

\ccHasModels\ccc{ArrangementBasicTraits_2::Equal_2}

\ccCreationVariable{fo}
\ccMethod{bool operator()(ArrTraits::Point_2 p1, ArrTraits::Point_2 p2);}
  {determines whether \ccc{p1} and \ccc{p2} are geometrically 
  equivalent.}
\ccGlue
\ccMethod{bool operator()(ArrTraits::X_monotone_curve_2 xc1,
                          ArrTraits::X_monotone_curve_2 xc2);}
  {determines whether \ccc{xc1} and \ccc{xc2} are
  geometrically equivalent (have the same graph).}
\end{ccRefConcept}
\ccRefPageEnd
