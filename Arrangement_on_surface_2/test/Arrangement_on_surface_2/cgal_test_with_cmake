#! /bin/sh

# This is a script for the CGAL test suite. Such a script must obey
# the following rules:
#
# - the name of the script is cgal_test_with_cmake
# - for every target two one line messages are written to the file 'error.txt'
#     the first one indicates if the compilation was successful
#     the second one indicates if the execution was successful
#   if one of the two was not successful, the line should start with 'ERROR:'
# - running the script should not require any user interaction
# - the script should clean up object files and executables

  ERRORFILE=error.txt
  DO_RUN=y
  if [ -z "${MAKE_CMD}" ]; then
    MAKE_CMD=make
  fi
  NEED_CLEAN=

#---------------------------------------------------------------------#
#                    configure
#---------------------------------------------------------------------#

configure()
{
  echo "Configuring... "

  if eval 'cmake "$CMAKE_GENERATOR" -DRUNNING_CGAL_AUTO_TEST=TRUE  \
                                     -DCGAL_DIR="$CGAL_DIR" \
                                     .' ; then

    echo "   successful configuration" >> $ERRORFILE
  else
    echo "   ERROR:    configuration" >> $ERRORFILE
  fi
}

#---------------------------------------------------------------------#
#                    compile_and_run <target>
#---------------------------------------------------------------------#

compile_and_run()
{
  echo "Compiling $1 ... "
  SUCCESS="y"

  if eval '${MAKE_CMD} VERBOSE=ON -fMakefile $1' ; then
    echo "   successful compilation of $1" >> $ERRORFILE
  else
    echo "   ERROR:    compilation of $1" >> $ERRORFILE
    SUCCESS=""
  fi

  if [ -n "$DO_RUN" ] ; then
    if [ -n "${SUCCESS}" ] ; then
      OUTPUTFILE=ProgramOutput.$1.$PLATFORM
      rm -f $OUTPUTFILE
      COMMAND="./$1"
      if [ -f $1.cmd ] ; then
        COMMAND="$COMMAND `cat $1.cmd`"
      fi
      if [ -f $1.cin ] ; then
        COMMAND="cat $1.cin | $COMMAND"
      fi
      echo "Executing $1 ... "
      echo
      ulimit -t 3600 2> /dev/null
      if eval $COMMAND > $OUTPUTFILE 2>&1 ; then
        echo "   successful execution   of $1" >> $ERRORFILE
      else
        echo "   ERROR:    execution   of $1" >> $ERRORFILE
      fi
    else
      echo   "   ERROR:    not executed   $1" >> $ERRORFILE
    fi
  fi
}

#---------------------------------------------------------------------#
#                    remove the previous error file
#---------------------------------------------------------------------#

rm -f $ERRORFILE
touch $ERRORFILE

#---------------------------------------------------------------------#
#                    configure, compile and run the tests
#---------------------------------------------------------------------#

configure

if [ $# -ne 0 ] ; then
  for file in $* ; do
    compile_and_run $file
  done
else
  echo "Run all tests."
if  ${MAKE_CMD} -f Makefile help | grep -E "construction_test_suite_generator$" > /dev/null; then
  compile_and_run construction_test_suite_generator
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "ex_kernel_point$" > /dev/null; then
  compile_and_run ex_kernel_point
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "ex_kernel_segment$" > /dev/null; then
  compile_and_run ex_kernel_segment
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "point_location$" > /dev/null; then
  compile_and_run point_location
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_construction$" > /dev/null; then
  compile_and_run test_construction
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_do_equal$" > /dev/null; then
  compile_and_run test_do_equal
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_do_intersect$" > /dev/null; then
  compile_and_run test_do_intersect
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_dual$" > /dev/null; then
  compile_and_run test_dual
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_insertion$" > /dev/null; then
  compile_and_run test_insertion
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_iso_verts$" > /dev/null; then
  compile_and_run test_iso_verts
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_observer$" > /dev/null; then
  compile_and_run test_observer
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_rational_function_traits_2$" > /dev/null; then
  compile_and_run test_rational_function_traits_2
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_rectangular_hyperbola_with_iso_asymptotes_traits_2$" > /dev/null; then
  compile_and_run test_rectangular_hyperbola_with_iso_asymptotes_traits_2
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_removal$" > /dev/null; then
  compile_and_run test_removal
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_tags$" > /dev/null; then
  compile_and_run test_tags
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_traits_adaptor$" > /dev/null; then
  compile_and_run test_traits_adaptor
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_traits$" > /dev/null; then
  compile_and_run test_traits
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_traits_dispatching$" > /dev/null; then
  compile_and_run test_traits_dispatching
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_unbounded_rational_insertion$" > /dev/null; then
  compile_and_run test_unbounded_rational_insertion
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_vertical_segment_traits$" > /dev/null; then
  compile_and_run test_vertical_segment_traits
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_vert_ray_shoot_vert_segments$" > /dev/null; then
  compile_and_run test_vert_ray_shoot_vert_segments
  NEED_CLEAN=y
fi
if  ${MAKE_CMD} -f Makefile help | grep -E "test_zone$" > /dev/null; then
  compile_and_run test_zone
  NEED_CLEAN=y
fi
fi

#
# The clean target generated by CMake under cygwin
# always fails for some reason
#
if [ -n "${NEED_CLEAN}" ]; then
  if ! ( uname | grep -q "CYGWIN" ) ; then
    ${MAKE_CMD} -fMakefile clean
  fi
fi
