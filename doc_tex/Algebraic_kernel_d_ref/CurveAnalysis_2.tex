\begin{ccRefConcept}{CurveAnalysis_2::StatusLine_1}

\ccDefinition

Given a vertical line~$\ell$ at $x = x_0$. A curve can either have finitely
many intersection $(x_0,y_j)$ with~$\ell$, or $\ell$ is
completely contained in the curve. In the latter case, we are still interested
in finitely many points $(x_0,y_j)$ where non-vertical arcs of the curve
intersect~$\ell$. 

The \ccc{StatusLine_1} concept is meant to provide information
about those points of interest, called ``$y$-events'', of a curve with a
vertical line at a given finite $x$-coordinate and whether~$\ell$ is contained
in the curve.
That is, the concept's methods interface the local topology of the curve. A
status line at any $x_0$ smaller than any $x$-coordinate of a curve's
$x$-critical points captures the topology of the curve when 
approaching $x = -\infty$. An analogue argument holds for $x_0$ larger than any
$x$-coordinate of a curve's status lines and $x = +\infty$.

\ccTypes

\ccNestedType{size_type}{A instance of a size type, for instance, \ccc{int}}

\ccNestedType{Algebraic_real_1}{A model of the concept
  \ccc{AlgebraicKernel_d_1::AlgebraicReal_1}.}

\ccNestedType{Algebraic_real_2}{A model of the concept
  \ccc{AlgebraicKernel_d_2::Algebraic_real_2}.}

\ccCreationVariable{sl}
\ccAccessFunctions

\ccMethod{Algebraic_real_1 x();}{
  returns the $x$-coordinate of the vertical line (always a finite value).
}

\ccMethod{bool covers_line();}{
  returns \ccc{true} in case the given curve contains the vertical line as
  a component
}

\ccMethod{size_type number_of_events();}{
  returns number of distinct and finite $y$-events of a curve
  with the vertical line~$\ell$.
}

\ccMethod{Algebraic_real_2 algebraic_real_2(size_type j);}{
  returns an object of type \ccc{Algebraic_real_2} for the $j$-th event, in
  increasing $y$-order.
  \ccPrecond{$0 \leq j < \mbox{number\_of\_events()}$}.
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_incident_branches(size_type j);}{
  returns the number of branches (a branch is an arc of a curve containing a
  non-compact sequence) of the curve connected to $j$-th event
  immediately to the left,
  to the right, respectively, as a pair of \ccc{size_type} ignoring 
  vertical curve components at the given $x$-coordinate.
  \ccPrecond{$0 \leq j < \mbox{number\_of\_events()}$}
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_branches_approaching_minus_infinity();}{
  returns the number of the curve's non-vertical branches that have the status
  line as vertical asympote and that approach $y=-\infty$. We distinguish
  between approachings from left (\ccc{pair.first}) and approaches from right
  (\ccc{pair.second}).
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_branches_approaching_plus_infinity();}{
  returns the number of the curve's non-vertical branches that have the status
  line as vertical asympote and that approach $y=+\infty$. We distinguish
  between approachings from left (\ccc{pair.first}) and approaches from right
  (\ccc{pair.second}).
}

\ccMethod{bool has_x_critical_point();}{
  returns \ccc{true} if the curve defined by polynomial~$p$ has an intersection
  with the algebraic curve defined by its partial derivative with respect
  to~$y$, namely $p_y := \frac{\partial p}{\partial y}$, at $x$.
}

\ccMethod{bool is_event();}{
  returns \ccc{true} if one of \ccc{has_x_critical_point()} or 
  \ccc{covers_line()} evaluates to \ccc{true}.
}

\end{ccRefConcept}

\begin{ccRefConcept}{AlgebraicKernelWithAnalysis_d_2::CurveAnalysis_2}

\ccDefinition

The \ccc{AlgebraicKernel_d_2::CurveAnalysis_2}
concept\footnote{There is no need
for curves to be algebraic, hence the generic name. Only the number
of events must be finite.}
 is meant to provide tools to analyze a single
curve. An analysis is meant to describe the curve's interesting points and how 
they are connected. The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinates. Each such coordinate defines
a \ccc{StatusLine_1} of an event. These coordinates also define open 
{\it intervals} on the $x$-axis. Different 
\ccc{StatusLine_1} at different $x$-coordinates within one 
such interval provide the same combinatorial representation, but differ
in the accessible \ccc{Algebraic_real_2} instances (those differ in 
$x$- and probably also in their $y$-coordinates. Namely, if the curve is not
horizontal along the corresponding arc over the interval). 
Topological information is equal for all $x$-coordinate inside such an
open interval. If there a $n$ $x$-coordinate that have an event point, we 
see at most $2n+1$ topologically different status lines, that is, $n$ for 
the events, and $n+1$ for the intervals between events (and before the 
first, and after the last event).

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes

\ccNestedType{size_type}{A instance of a size type, for instance, \ccc{int}}

\ccNestedType{Algebraic_real_1}{A model of the concept
  \ccc{AlgebraicKernel_d_1::AlgebraicReal_1}.}

\ccNestedType{Algebraic_real_2}{A model of the concept
  \ccc{AlgebraicKernel_d_2::Algebraic_real_2}.}

\ccNestedType{Polynomial_2}{A model of the concept 
  \ccc{AlgebraicKernel_d_2::Polynomial_2}.}

\ccNestedType{Curve_vertical_line_1}{A model of the concept
\ccc{CurveAnalysis_2::StatusLine_1}.}

\ccCreation
\ccCreationVariable{ca}
        
\ccConstructor{CurveAnalysis_2(Polynomial_2 p);}
    {constructs an analysis for the curve defined by p. 
\ccPrecond{The polynomial must be square free.}
}

\begin{ccAdvanced}

\ccConstructor{template < class InputIterator >
  CurveAnalysis_2(Polynomial_2 p, InputIterator begin, InputIterator end);}{
  constructs an analysis for the curve defined by p. The iterator range 
  [begin,end) contains factors of $\mbox{resultant}(p,p_y,y)$ 
  that is, their roots define $x$-coordinates of events.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_1}. 
\ccPrecond{Each given polynomial must be square free.}
}
  This constructor has been introduced to enable an outside instance 
  (e.g., a geometric curved kernel relying on this algebraic kernel) to
  propagate additional knowledge useful for the analysis. The factors are a way
  to enable a simplified computation of the curve's critical $x$-coordinates.
  (e.g., no square-free decomposition needed). In the best case, the given
  polynomials are minimal for the roots they define.

  The constructor is optional in the sense, that if the signature is not
  provided by a model, but demanded by external soure code, a compile error is
  reported.
\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Polynomial_2 polynomial_2();}{
  returns the defining polynomial of the analysis
}

\ccMethod{size_type number_of_status_lines_with_event();}{
  returns number of vertical lines that encode an event
}

\ccMethod{Status_line_1 status_line_at_event(size_type i);}{
  returns an instance of \ccc{StatusLine_1} at the $i$-th event (in increasing
 order of $x$-coordinates)
 \ccPrecond{$0 \leq i < $ \ccc{number_of_status_lines_with_event()}}
}

\ccMethod{Status_line_1 status_line_of_interval(size_type i);}{
  returns an instance of \ccc{StatusLine_1} of the $i$-th interval (in
  increasing order of $x$-coordinates)
  between $x$-events. The $x$-coordinate at which the status line is
  an arbitrary and uncontrollable representative chosen within the indicated
  interval. If a specific one is desired, the next two operator provide proper
  access.
 \ccPrecond{$0 \leq i \leq $ \ccc{number_of_status_lines_with_event()}}
}

\ccMethod{Status_line_1 status_line_for_x(Algebraic_real_1 x, 
  CGAL::Sign perturb = CGAL::ZERO);}{
 returns status\_line\_at\_event(i), if $x$ hits $i$-th event (in increasing
 order of $x$-coordinates), otherwise
 returns status\_line\_of\_interval(i). If $pertub$ is CGAL::NEGATIVE
(CGAL::POSITIVE) and $x$ states
  an event, then status\_line\_of\_interval(i) 
  (status\_line\_of\_interval(i+1)) is returned.
  The purpose of the operation is to slightly perturb an $x$-coordinate in
  order to return some status line in an incident interval.
  \ccPrecond{$x$ is finite}
}

\ccMethod{Status_line_1 status_line_at_exact_x(Algebraic_real_1 x);}{
  returns an instance of \ccc{StatusLine_1} at the given~$x$.
  \ccPrecond{$x$ is finite}
}

Note that the access methods to status lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search for
some $x$, or the unique representative status line for an interval),
while the ones with given $x$ still perform a look-up. There is also a 
difference between \ccc{ status_line_for_x(x0,CGAL::ZERO)} and 
\ccc{status_line_at_exact_x(x0)} in the case \ccc{x0} is contained 
in an interval between events. Namely, the former is allowed to return a
precomputed representative for the interval, while the later enforces
a status line exactly at the given \ccc{x0} which implies that the 
$y$-coordinates are with respect to the given \ccc{x0}. In the first case,
the accesible $y$-coordinates are with respect to the representative's 
$x$-coordinate only.

%\begin{ccAdvanced}
%
%\ccMethod{size_type find(Algebraic_real_2 s);}{
%  returns the index of the event at the status line defined by 
%  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on the curve.
%}
%
%\end{ccAdvanced}

\ccMethod{CGAL::Object asymptotic_value_of_arc(CGAL::Arr_parameter_space loc, 
  size_type arcno);}{
  returns a CGAL::Object that encodes the asymptotic value of a curve-arc 
  approaching the left or the right boundary ($loc$) of the underlying
  parameter space. Allowed instantiations of the CGAL::Object are 
  \ccc{Algebraic_real_1}, in case the x-asympote of the arc is finite,
  or \ccc{CGAL::ARR_BOTTOM_BOUNDARY} and \ccc{CGAL::ARR_TOP_BOUNDARY} in case
  the defined arc approaches the respective corners of the parameter space.
  \ccPrecond{$loc$ is either \ccc{CGAL::ARR_LEFT_BOUNDARY} or 
    \ccc{CGAL::ARR_RIGHT_BOUNDARY}}
}

In our $y$-per-$x$-view we imagine the space to be slightly 
higher than it is wide and so we distinguish three aymptotic behaviors
of arcs. Horizontal, vertical, and none of them. This member covers 
all non-vertical asymptotes. We do not introduce a special one
for vertical asympototes as the respective $x$-coordinates are already defined
by proper status lines.

In addition, by using the parameter space locations, 
we decouple the interface from the unbounded plane. An example is a 
two-dimensional arrangement embedded on a torus.

\end{ccRefConcept}
