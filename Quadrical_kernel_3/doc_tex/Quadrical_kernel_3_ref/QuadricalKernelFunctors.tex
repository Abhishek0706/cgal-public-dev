\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::CompareX_3}

\ccCreationVariable{cmp_x}

An object \ccVar\ of this type must provide:

\ccMemberFunction{CGAL::Comparison_result
	operator()(const QuadricalKernel_2::Curve_point_2 &pt1, const QuadricalKernel_2::Curve_point_2 &pt2);}
{Returns the order of the points' $x$-coordinates.}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::HasOn_3}

\ccCreationVariable{has_on}

An object \ccVar\ of this type must provide:

\ccMemberFunction{bool 
	operator()(const Type1 &obj1, const Type2 &obj2);}
{Returns \ccc{true} when \ccc{obj1} contains \ccc{obj2},}

where we \ccc{Type_1} $>$ \ccc{Type_1} with the defined order: \\

\begin{tabular}{lll}
\ccc{QuadricalKernel_3::Quadric_3}&$>$&\ccc{QuadricalKernel_3::Curve_3}\\
                                  &$>$&\ccc{QuadricalKernel_3::Curve_arc_3}\\
                                  &$>$&\ccc{QuadricalKernel_3::Curve_point_3}

\end{tabular}
\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ConstructQuadric_3}

\ccCreationVariable{con}

An object \ccVar\ of this type must provide:

\ccMemberFunction{QuadricalKernel_3::Quadric_3
  operator()(const QuadricalKernel_3::Polynomial_3& polynomial);}
{constructs the quadric from the \ccc{polynomial}. As a precondition
we have total\_degree(polynomial) $= 2$.}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ConstructCurve_3}

\ccCreationVariable{con}

An object \ccVar\ of this type must provide:

\ccMemberFunction{QuadricalKernel_3::Curve_3
  operator()(const QuadricalKernel_3::Quadric_3& q1, const QuadricalKernel_3::Quadric_3& q2);}
{constructs the intersection curve of \ccc{q1} and \ccc{q2}.}

\begin{ccAdvanced}

Depending on the decision what \ccc{Curve_3} represents,
it might be changed to 

\ccMemberFunction{
template< class OutputIterator >
OutputIterator
  operator()(const QuadricalKernel_3::Quadric_3& q1, const QuadricalKernel_3::Quadric_3& q2,
  OutputIterator oi);}
{constructs the intersection curves of \ccc{q1} and \ccc{q2} returning through
  \ccc{oi}.}

\end{ccAdvanced}


\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ArcsOfCurve_3}


\ccCreationVariable{arcs}

An object \ccVar\ of this type must provide:

\ccMemberFunction{
template< class OutputIterator >
OutputIterator
  operator()(const QuadricalKernel_3::Curve_3& curve, OutputIterator oi);}
{decomposes a curve into maximal objects of type 
\ccc{QuadricalKernel::Curve_arc_3} and returning them through \ccc{oi}.}

\ccMemberFunction{
template< class OutputIterator >
OutputIterator
  operator()(const QuadricalKernel_3::Curve_3& curve, const QuadricalKernel_3::Quadric_3& q,
OutputIterator oi);}
{decomposes a curve into maximal objects of type 
\ccc{QuadricalKernel::Curve_arc_3} when intersected with \ccc{q} 
and returning them through \ccc{oi}. As a precondition we have \ccc{q} does
not define \ccc{curve}.}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::Intersect_3}

\ccRefines

\ccc{Kernel::Intersect_3}

\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{template < class OutputIterator >
    OutputIterator
    operator()(const Type1 &obj1, const Type2 &obj2,
	OutputIterator intersections);}
{Copies in the output iterator the intersection elements between the
two objects. \ccc{intersections} iterates on
elements of type \ccc{CGAL::Object}, in lexicographic order
(where appropriate). See below for more precisions.}

%\ccMemberFunction{template < class OutputIterator >
%    OutputIterator
%    operator()(const Type1 &obj1, const Type2 &obj2,
%	const Type3 &obj3,
%	OutputIterator intersections);}
%{Copies in the output iterator the intersection elements between the
%two objects. \ccc{intersections} iterates on
%elements of type \ccc{CGAL::Object}, in lexicographic order 
%(where appropriate). See below for more precisions.}

\ccc{Type_1} and \ccc{Type_2} can both 
be either

\begin{itemize}
\item {} \ccc{QuadricalKernel_3::Quadric_3},
\item {} \ccc{QuadricalKernel_3::Linear_kernel_3::Plane_3},
\item {} \ccc{QuadricalKernel_3::Curve_3},
\item {} \ccc{QuadricalKernel_3::Curve_arc_3},
\end{itemize} 

and depending on the types \ccc{Type_1} and \ccc{Type_2}, the computed 
\ccc{CGAL::Object}s be assigned to pairs of
\ccc{Quadric_3}, \ccc{Curve_3}, \ccc{Curve_arc_3}, or \ccc{Curve_point_3}
and {\tt unsigned int} where the first part describe
one object that both input objects have in common, and the second
value gives its multiplicity. Note that, e.g., two quadrics
can intersect in a rational plane. 
An example are plane-pairs that have one plane in common.
%Similar for curves and arcs.

\end{ccRefFunctionObjectConcept}
