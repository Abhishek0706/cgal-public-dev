
#ifndef _BLOCK_UPDATES_GJG_NEW_C_
#define _BLOCK_UPDATES_GJG_NEW_C_

#include <include/generator_defs.h>
#include <include/modular_arithm.h>

namespace CGAL {

namespace internal {

bool g_save = false;
std::vector< zmod > g_debug;

//! first phase of generator updates: compute L factors of \c gs and \c ms and save them to \c gs_up and \c ms_up resp.
//! \c [g_start;g_beyond) - index range for \c gs
//! \c [i_start;i_beyond) - index range for \c ms

//! generates an updating sequence using generator columns of \c gs
template < class NT >
void _generate_bulge_1(const Generator< NT >& gs, GJG_update< NT >& L,
        unsigned g_start, unsigned g_beyond,
            bool full_update = true) {

    unsigned j = g_start, i; // j is a leading element index
    NT a0 = gs.a[j], b0 = gs.b[j], c0 = gs.c[j], d0 = gs.d[j];

    for(i = g_start; (int)i < (int)g_beyond; i++) {
        NT t = a0 * gs.a[i] + b0 * gs.b[i];
        if(full_update)
            t = t - c0 * gs.c[i] - d0 * gs.d[i];
        L[i] = t;
    }
}

//! update elements of \c ms using transformation generated by \c gs[j]
template < class NT >
void _update_1(Generator< NT >& ms, GJG_update< NT >& L,
        const Generator< NT >& gs, unsigned j, unsigned i_start,
        unsigned i_beyond, bool full_update = true) {

    unsigned i; 
    NT a0 = gs.a[j], b0 = gs.b[j], c0 = gs.c[j], d0 = gs.d[j];

    for(i = i_start; (int)i < (int)i_beyond; i++) {
        NT t = a0 * ms.a[i] + b0 * ms.b[i];
        if(full_update)
            t = t - c0 * ms.c[i] - d0 * ms.d[i];
        L[i] = t;
    }
}

//! \c full_update - indicates that full iterations are performed
template < class NT >
void _update_2(Generator< NT >& ms, const GJG_update< NT >& L,
        const Generator< NT >& gs, unsigned j,
        const NT& det, unsigned i_start, unsigned i_beyond,
            bool full_update = true) {

    unsigned i; // j is a leading element index
    NT a0 = gs.a[j], b0 = gs.b[j], c0 = gs.c[j], d0 = gs.d[j];

    // in fact det can be extracted from ms_up ??
    for(i = i_start; (int)i < (int)i_beyond; i++) {
        ms.a[i] = ms.a[i] * det - L[i] * a0;
        ms.b[i] = ms.b[i] * det - L[i] * b0;
        if(full_update) {
            ms.c[i] = ms.c[i] * det - L[i] * c0;
            ms.d[i] = ms.d[i] * det - L[i] * d0;
        }
    }
}

template < class NT >
void _setup_full(Generator< NT >& gs, const NT& res,
        unsigned g_start, unsigned g_beyond) {

    unsigned i;
    for(i = g_start; (int)i < (int)g_beyond; i++) {
        gs.c[i] = gs.c[i] * res;
        gs.d[i] = gs.d[i] * res;
    }
}

//! shifts down the elements of \c v_in and inserts them to \c v_out
//! the element \c a_in is optionally inserted at the top of \c v_out
//! only elements in the range \c [i_start;i_beyond) affected
//! \c v_in can be equal to \c v_out
template < class NT >
void _shiftdown(GJG_update< NT >& v_out, const GJG_update< NT >& v_in,
        unsigned i_start, unsigned i_beyond, const NT *a_in = 0) {

    unsigned i;
    for(i = i_beyond - 1; (int)i > (int)i_start; i--) {
        v_out[i] = v_in[i] - v_in[i - 1];
    }
    if(a_in != 0) {
        v_out[i_start] = v_in[i_start] - *a_in;
//         printf("inserting element: %d - %d\n:", v.a[i_start].x, a_in.x);
    }
}

bool gcd_found = false;
unsigned g_break_i = -1u;
std::vector< zmod > gcd_vector;
        
//! runs \c n steps of schur algorithm starting with iteration \c iter_idx
//! updates are generated \c gs and applied to \c ms
//! full updates start with iteration \c switch_idx
//! if \c ins <> 0, it is used to update elements from \c ms otherwise \c ms
//! is updated in a ``stair-like'' fashion
//! \c shift_through : elements shifted out from \c gs are inserted at the top
//! of \c ms (in other words, gs == ins reversed)
template < class NT >
void schur_block_new(Generator< NT >& gs, Generator< NT >& ms,
       NT& res, NT& denom, unsigned iter_idx, unsigned switch_idx,
        unsigned n1, unsigned n2, unsigned ofs, bool shift_through,
        GJG_update< NT > *ins = 0, GJG_update< NT > *outs = 0) {

    unsigned g_sz = gs.a.size(), m_sz = ms.a.size(), i, j,
        i_start = 0, i_beyond = m_sz;

    bool use_ins = (ins != 0), use_outs = (outs != 0);
    if(use_ins) { // in case ins is used we update in reverse ``stair-like''
                  // fashion
        i_beyond = 1;
    }

    unsigned sz = std::max(m_sz, g_sz);
    GJG_update< NT > gs_L(g_sz, NT(0)), L(sz, NT(0)), ms_L(m_sz, NT(0));

    NT res0(0);
    gcd_found = false;
    // step 1: generate the sequence of updates, a ``bulge''
    for(j = 0, i = iter_idx; j < n1; j++, i++) {

        bool full_update = (i >= switch_idx);
        if(i == switch_idx) {
            res0 = res;
//              printf("%d: setting up full iters: det = %d\n", j, res0.x);
            _setup_full(gs, res0, j, g_sz);
            //break; //! HACK HACK HACK: does not continue with full iterations
        }

        _generate_bulge_1(gs, gs_L, j, g_sz, full_update);
        NT det = gs_L[j];
        denom = denom * res * res, res = res * det;
        // keep the last element for shift-through
        if(shift_through) { // shift_through is always used with 'outs'
            (*outs)[j] = gs_L[g_sz - 1];
        }
        _shiftdown(L, gs_L, j, g_sz);

        // skip updating the first element otherwise it will be zeroed out
        _update_2(gs, L, gs, j, det, j+1, g_sz, full_update);
        // condition is: a*a + b*b - c*c - d*d == 0
        if(full_update && !gcd_found && j < n1-1 &&
                gs.a[j+1] == gs.c[j+1] && gs.b[j+1] == gs.d[j+1]) {
            printf("########### found gcd at iteration: %d\n", j);
            gcd_found = true, g_break_i = j;
//             print_inv_vector(gs_L, gs_L[g_break_i], j, g_sz);
            // this always corresponds to 0th part
            std::copy(gs_L.begin() + j, gs_L.begin() + n1, gcd_vector.begin());
            break;
        }
//          if(i == switch_idx) break;
    }
//     if(g_save)
//         g_debug = *outs;
    if(gcd_found) {
        n2 = g_break_i+1; // do not run further iterations
    }
    // gs: generating sequence, gs_L: set of dets
    // outs: elements being inserted
    for(j = 0, i = iter_idx; (int)j < (int)n2; j++, i++) {

        bool full_update = (i >= switch_idx);
        if(i == switch_idx) {
//             printf("??????? setting up full iters: det = %d\n", res0.x);
            if(!use_ins)
                _setup_full(ms, res0, 0, m_sz);
            //break; //! HACK HACK HACK: does not continue with full iterations
        }

         if(gcd_found && j == g_break_i && (use_ins || shift_through)) {
            _update_1(ms, ms_L, gs, j, 0, m_sz, full_update);
            // shift to the left by g_break_i because the leading block
            // has only [g_sz - g_break_i] elements
            std::copy(ms_L.begin(), ms_L.end(), gcd_vector.begin() +
                    ofs - g_break_i);
        } else {
            
            _update_1(ms, ms_L, gs, j, i_start, i_beyond, full_update);
        }

        NT a_in, *pa = &a_in;
        // we can reuse 'outs' to implement shift-through here
        if(shift_through) 
            a_in = (*outs)[j];
        else if(use_ins) 
            a_in = (*ins)[j];
        else {
            i_start++, pa = 0;
        }
        if(use_outs)
            (*outs)[j] = ms_L[m_sz - 1];

        // NOTE: we have to break the loop here during stair-like iterations
        // otherwise we won't be able to recover the gcd during 'use_ins' iters
        if(!use_ins && j == g_break_i && gcd_found)
            break;

        _shiftdown(L, ms_L, 0, m_sz, pa);
        // gs_L is used for 'dets'
        _update_2(ms, L, gs, j, gs_L[j], i_start, i_beyond, full_update);

        if(use_ins) {
            i_beyond++;
            // NOTE guard is needed if n > m_sz which can occur for the last
            if(i_beyond > m_sz) // block
                i_beyond = m_sz;
        }
// NOTE NOTE
//         if(i == switch_idx) break;
    }
    if((i >= switch_idx) && (use_ins || shift_through)
                && !gcd_found && m_sz != 0) {
        if(ms.a[0] != NT(0) && ms.a[0] == ms.c[0] && ms.b[0] == ms.d[0]) {
        // NOTE: here something is mixed up with 'use_ins' iterations..
        // need to figure out why the results not always correct
            printf("ATTENTION: gcd found at the corner case!!!\n");
            // magically, the first entry comes from gs_L
            gcd_vector[0] = gs_L[g_sz - 1];
            std::copy(ms_L.begin(), ms_L.end(), gcd_vector.begin() +
                    ofs - n1 + 1);
            gcd_found = true;
        }
    }
}
    
template < class NT, unsigned N >
unsigned block_schur_QR_new(const std::vector< NT >& v1,
         const std::vector< NT >& v2, unsigned *out = 0,
            unsigned o_stride = 1) {

    unsigned n = v1.size()-1, m = v2.size()-1, r = n + m, i, j, k;
    if(n < m) {
        printf("block_schur_QR_new: incorrect parameters !!\n");
        throw 1;
    }
    unsigned n_blocks = (r + N - 1) / (2*N), n_last = r - n_blocks * 2*N + N;
    
    printf("block_schur_QR_new N: %d; r: %d; n_blocks: %d; n_last: %d\n",
            N, r, n_blocks, n_last); 
        
    NT v1lc = v1[n];
    NT inv1(mod_inverse(v1lc.x, zmod::modulus)), inv2(1);

    std::vector< NT > a(r, NT(0)), b(r, NT(0)), c(r, NT(0)), d(r, NT(0));
    for(i = 0; i <= n; i++) {
        a[i] = (i <= n ? v1[n - i] : NT(0));
        b[i] = (i <= m ? v2[m - i] : NT(0));
        
        if(i < n)
            c[i + m] = v1[n - i];
        if(i < m)
            d[i + n] = v2[m - i];
    } 
    gcd_found = false; //! reset the global flag
    
    typedef Generator< NT > GJG;
    typedef GJG_update< NT > GJG_up;
    
    typename std::vector< NT >::const_iterator ai = a.begin(),
            bi = b.begin(), ci = c.begin(), di = d.begin();
    
    GJG gs0(N, ai, bi, ci, di), gs, tmp(N);
    std::vector< GJG > msv(n_blocks);
    std::vector< GJG_up > outsv(n_blocks);
    GJG *ms = (GJG *)msv.data();
    GJG_up *outs = (GJG_up *)outsv.data();

    // distribute data btw blocks
    unsigned ofs;
    for(i = 0, ofs = N; i < n_blocks - 1; i++, ofs += N*2) {
        ms[i] = GJG(N*2, ai + ofs, bi + ofs, ci + ofs, di + ofs);
        outs[i] = GJG_up(N);
    }
    ms[n_blocks - 1] = GJG(n_last, ai + ofs, bi + ofs, ci + ofs,
            di + ofs);
    outs[n_blocks - 1] = GJG_up(N); // last block does not need outs

    // though we do not need such a large vector 
    gcd_vector = std::vector< NT >(r, NT(0));

    NT res0(1), denom0(1), res1, denom1;
    unsigned iter_idx = 0, switch_idx = m; // algorithm iteration counter

//! Directions to compute the modular gcd:
//! 1. compute monic gcd, then multiply it by gcd(lcoeff(f),lcoeff(g)) which
//! is the leading coefficient of gcd polynomial, hence it's guaranteed that
//! the resulting polynomial is integer
//! the bitlegth of gcd coefficients is determined by the minimal bitlength of
//! two polynomials f & g
//! primes need to be chosen so that they do not divide the leading coeff
//! of either polynomial

#if 0
    unsigned shift = 0;
    j = 0;
    for(j = 0; j < 2*n_blocks - 1; j++) {
    unsigned jdiv2 = j / 2;

    for(i = jdiv2; i < n_blocks; i++) {
        // limit the number of iterations for the last block
        unsigned n_iters = (i < n_blocks - 1 ? N : n_last);

        gs = gs0, res1 = res0, denom1 = denom0;
        GJG_up *pout = &outs[i]; //  (i < n_blocks - 1 ? &outs[i] : 0);

        g_save = (i == jdiv2)/* && (j==3)*/;
        schur_block_new(gs, ms[i], res1, denom1, iter_idx, switch_idx,
            N, N, ofs, (i == jdiv2), (GJG_up *)0, pout);
    }

    for(i = jdiv2 + 1; i < n_blocks; i++) {
        gs = gs0, res1 = res0, denom1 = denom0;
        schur_block_new(gs, ms[i], res1, denom1, iter_idx, switch_idx,
            N, N, ofs, false, &outs[i - 1]);
    }

//! NOTE: if you break at the transition to full iterations, you have to run
//! one full iteration additionally otherwise results will differ !!
     if(j == DEBUG_ITER_IDX+26) break;
//     if(iter_idx + N > m) { // indicates that we have run all ``lite'' iters
//         break;
//     }

    unsigned diff = r - (iter_idx + N);
//     if(diff <= 3*N) {
//         printf("%%%%%%%%%%%%% break at diff: %d; j: %d\n", diff, j);
//         break;
//     }

    if(j % 2 == 0) {
        // copy first N rows from ms[j] to gs0
        gs0.assign_range(0, N, ms[jdiv2]);
        // the upper half goes into ``short'' ms
        tmp.assign_range(N, 2*N, ms[jdiv2]);
        ms[jdiv2] = tmp;
    } else
        gs0 = ms[jdiv2];

    iter_idx += N; 
    res0 = res1, denom0 = denom1; // and determinant as well
    } // for(j)

//     gs = gs0, res1 = res0, denom1 = denom0;
//     GJG_up *pout = &outs[0]; //  (i < n_blocks - 1 ? &outs[i] : 0);
// 
// //     g_save = true;
//     schur_block_new(gs, ms[0], res1, denom1, iter_idx, switch_idx,
//             N, N, 0, true, (GJG_up *)0, pout);
//         fillout(res1, out, o_stride, N);

/*       writeout(ms[0].a, out, o_stride, 0, N);
       writeout(ms[1].a, out+N*o_stride, o_stride, 0, N);*/
 
//     writeout(gs0.a, out, o_stride, 0, N);

//      writeout(g_debug, out+s*o_stride, o_stride, 0, N);
//      writeout(ms[1].a, out, o_stride, 0, N);
#else

    for(j = 0; j < 2*n_blocks - 1; j++) {

//         printf("\n======= iteration: %d ============\n", j);

        unsigned jdiv2 = j / 2, ofs = gs.a.size();

        for(i = jdiv2; i < n_blocks; i++) {
            // limit the number of iterations for the last block
            unsigned n_iters = (i < n_blocks - 1 ? N : n_last);

            gs = gs0, res1 = res0, denom1 = denom0;
            GJG_up *pout = &outs[i]; //  (i < n_blocks - 1 ? &outs[i] : 0);

            schur_block_new(gs, ms[i], res1, denom1, iter_idx, switch_idx,
              N, N, ofs, (i == jdiv2), (GJG_up *)0, pout);
            // ofs only relates to 'ms' offset, 'gs' is not taken into account
            ofs += ms[i].a.size();
        }

        ofs = gs.a.size() + ms[jdiv2].a.size();
        for(i = jdiv2 + 1; i < n_blocks; i++) {
            gs = gs0, res1 = res0, denom1 = denom0;
            schur_block_new(gs, ms[i], res1, denom1, iter_idx, switch_idx,
                    N, N, ofs, false, &outs[i - 1]);
            ofs += ms[i].a.size();
        }

//     if(iter_idx + N > m) { // indicates that we have run all ``lite'' iters
//         break;
//     }

        if(gcd_found) {
            printf("gcd found at: j = %d; N: %d; n_blocks: %d\n",
                    j, r-iter_idx, n_blocks);
            break;
        }

        if(j == 2*n_blocks-2)
            break;
//         if((r-iter_idx) <= 3*N)
//             break;

        if(j % 2 == 0) {
            // copy first N rows from ms[j] to gs0
            gs0.assign_range(0, N, ms[jdiv2]);
            // the upper half goes into ``short'' ms
            tmp.assign_range(N, 2*N, ms[jdiv2]);
            ms[jdiv2] = tmp;
        } else
            gs0 = ms[jdiv2];

//         if((r-iter_idx) <= 3*N)
//             break;

        iter_idx += N;

        res0 = res1, denom0 = denom1; // and determinant as well
    } // for(j)

    printf("break loop with iter_idx = %d; j = %d\n", r-iter_idx, j);

#if 0
    unsigned idx = 0, jdiv2 = j / 2; //! block index

    printf("jdiv2: %d; n_blocks: %d\n", jdiv2, n_blocks);

    if(idx == 0) {
        if((j & 1) == 0) { // write out the leading block
            writeout(ms[jdiv2].c, out, o_stride, 0, N*2);
        } else {
            writeout(ms[jdiv2].c, out, o_stride, 0, N);
            if(jdiv2 + 1 < n_blocks)
                writeout(ms[jdiv2 + 1].c, out+N*o_stride, o_stride, 0, N);
        }
    } else {
        if((j & 1) == 0) { // write out the leading block
            writeout(ms[jdiv2+idx].c, out, o_stride, 0, N*2);
        } else {
            writeout(ms[jdiv2+idx].c, out, o_stride, N, N*2);
            if(jdiv2+idx+1 < n_blocks)
                writeout(ms[jdiv2+idx+1].c, out+N*o_stride, o_stride, 0, N);
        }
    }
    
#else


    if(!gcd_found) {
        iter_idx += N;
//         printf("%%%%%%%%%%%% the last run %%%%%%%%%%%%\n");
        GJG dummy;
        schur_block_new(ms[n_blocks-1], dummy, res1, denom1,
                iter_idx, switch_idx, n_last, n_last, 0, false);
    }
    unsigned sz = 0;

    if(gcd_found) {
        sz = r - (iter_idx + g_break_i);
        printf("\n################# gcd vector: %d ##################\n", sz);
//         print_inv_vector(gcd_vector, gcd_vector[0], 0, gcd_vector.size());
//         print_vector(g_debug);
        writeout(gcd_vector, out, o_stride, 0, m+1);
//         writeout(g_debug, out, o_stride, 0, g_debug.size());
    }
    return sz;

#endif

#endif
//     printf("CHECK res = %d; denom = %d\n", res1.x, denom1.x);
}

} // namespace internal

} // namespace CGAL

#endif // _BLOCK_UPDATES_GJG_NEW_C_
