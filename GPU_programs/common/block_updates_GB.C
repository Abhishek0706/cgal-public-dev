
#ifndef _BLOCK_UPDATES_GB_C_
#define _BLOCK_UPDATES_GB_C_

#include <include/generator_defs.h>
#include <include/modular_arithm.h>

namespace CGAL {

namespace internal {

//! updates generators \c v using rotation generated by \c[a0;b0] and \c[c0;d0]
//! only elements in the range \c [i_start;i_beyond) affected 
template < class NT >
void _gb_update(Generator< NT >& v, const NT& a0, const NT& b0, 
        const NT& c0, const NT& d0, const NT& la, const NT& lc,
        unsigned i_start, unsigned i_beyond) {
    
    unsigned i;
    for(i = i_start; (int)i < (int)i_beyond; i++) { 
/** updates for new version 
        NT ai = la*(v.a[i]*c0 + v.b[i]*d0),
           bi = lc*(v.a[i]*b0 - v.b[i]*a0);
        v.a[i] = ai, v.b[i] = bi;

        NT ci = lc*(v.c[i]*a0 + v.d[i]*b0),
           di = la*(v.c[i]*d0 - v.d[i]*c0);
        v.c[i] = ci, v.d[i] = di;
/**/
/** updates for old version **/
        NT ai = la*(v.a[i] * c0 - v.b[i]*d0);
        v.b[i] = lc*(-v.a[i]*b0 + v.b[i]*a0);
        v.a[i] = ai;

        NT ci = lc*(v.c[i]*a0 - v.d[i]*b0);
        v.d[i] = la*(-v.c[i]*d0 + v.d[i]*c0);
        v.c[i] = ci;
    }
}

//! shifts down the first columns of generators \c v and optionally inserts
//! elements \c a0 and \c c0 to colums \c v.a and \c v.c at the position
//! marked by \c i_start ; only elements in the range \c [i_start;i_beyond)
//! affected 
template < class NT >
void _gb_shiftdown(Generator< NT >& v, const NT& a_in, const NT& c_in,
        unsigned i_start, unsigned i_beyond, bool insert) {

    unsigned i;
    for(i = i_beyond - 2; (int)i >= (int)i_start; i--) { 
        v.a[i + 1] = v.a[i]; 
        v.c[i + 1] = v.c[i]; 
    }
    if(insert) {
// std::cout << "###### elements to be shifted in: " << a0 << " and " <<
//         c0 << "\n";
        v.a[i_start] = a_in; 
        v.c[i_start] = c_in;
    }
}
        
//! runs \c n steps of schur algorithm with asymmetric rotations generated
//! by \c gs and applied to \c ms
//! if \c ins <> 0, it is used to update elements from \c ms otherwise \c ms
//! is updated in a ``stair-like'' fashion
//! \c shift_through : elements shifted out from \c gs are inserted at the top
//! of \c ms (in other words, gs == ins reversed)
template < class NT >
void schur_block(Generator< NT >& gs, Generator< NT >& ms,
       NT& la, NT& lc, NT& det, NT& denom, unsigned n, bool shift_through, 
        GB_update< NT > *ins = 0, GB_update< NT > *outs = 0) {

    unsigned g_sz = gs.a.size(), m_sz = ms.a.size(), i, j,
        i_start = 0, i_beyond = m_sz;

    bool use_ins = (ins != 0), use_outs = (outs != 0);
    if(use_ins) { // in case ins is used we update in reverse ``stair-like''
                  // fashion
        i_beyond = 0;
    }

    for(j = 0; j < n; j++) {
 
        NT a0 = gs.a[j], b0 = gs.b[j], c0 = gs.c[j], d0 = gs.d[j];

        if(use_ins) {
//             printf("use_ins: iter: %d; updating: [%d; %d)\n",
//                 j, i_start, i_beyond);
        }
// NOTE NOTE NOTE: you need to control the # of elements to be
// updated in the last generator
        _gb_update(gs, a0, b0, c0, d0, la, lc, j, g_sz);
        _gb_update(ms, a0, b0, c0, d0, la, lc, i_start, i_beyond);

        NT a_in(0), c_in(0), _(0);
        // it seems that la & lc should always match at any iteration
        // for debugging you can also keep det & denom variables
        lc = lc*lc*la; la = gs.a[j];
        det = det * gs.c[j]; denom = denom * lc;

        if(shift_through) {
            a_in = gs.a[g_sz - 1], c_in = gs.c[g_sz - 1];
        } else if(use_ins) {
            a_in = ins->a[j], c_in = ins->c[j];
            i_beyond++;
            // NOTE guard is needed if n > m_sz which can occur for the last
            if(i_beyond > m_sz) // block
                i_beyond = m_sz;
//             std::cout << "use_ins: next iter update: " << a_in <<
//                     " and " << c_in << "\n";
        } else {
            i_start++; 
        }

        if(use_outs) {
            outs->a[j] = ms.a[m_sz - 1];
            outs->c[j] = ms.c[m_sz - 1];
        }

        _gb_shiftdown(gs, _, _, j, g_sz, false);
        _gb_shiftdown(ms, a_in, c_in, 0, m_sz, use_ins | shift_through);
    }
}
    
template < class NT >
NT GB_updates_test(const std::vector< NT >& v1,
        const std::vector< NT >& v2) {

    unsigned n = v1.size()-1, m = v2.size()-1, r = n + m, i, j;

    const unsigned N = 6; // block size
    unsigned n_blocks = (r + N - 1) / N - 1,
        n_last = r - (n_blocks * N), // # of elements for the last block
        rN = (n_blocks + 1) * N;   // allocate padded generators

    printf("********* N: %d; r: %d; n_blocks: %d; n_last: %d ***********\n",
            N, r, n_blocks, n_last);

    zmod v1lc = v1[n];
    zmod inv1(mod_inverse(v1lc.x, zmod::modulus)), inv2(1);
    std::vector< NT > a(r, NT(0)), b(r, NT(0)), c(r, NT(0)), d(r, NT(0));

    // [a, b] = G; [c, d] = H
    a[0] = NT(1);
    b[m] = -NT(1);

    for(i = 0; i < r; i++) {
        c[i] = (i <= n ? v1[n - i] * inv1 : NT(0));
        d[i] = (i <= m ? v2[m - i] * inv2 : NT(0));
        if(i >= m)
            d[i] = d[i] - v1[r - i] * inv1;
        b[i] = i*i;
    }

// printf("########### original GB: \n");
//     print_vector(a);
//     print_vector(b);
//     print_vector(c);
//     print_vector(d);
// printf("\n###########  \n");

    typedef Generator< NT > GB;
    typedef GB_update< NT > GB_up;
    
    typename std::vector< NT >::const_iterator ai = a.begin(),
            bi = b.begin(), ci = c.begin(), di = d.begin();
    
    GB dummy, gs0(N, ai, bi, ci, di), gs;
    std::vector< GB > msv(n_blocks);
    std::vector< GB_up > outsv(n_blocks);
    // avoiding new operation
    GB *ms = (GB *)msv.data();
    GB_up *outs = (GB_up *)outsv.data();

    // distribute data btw blocks
    unsigned ofs;
    for(i = 0, ofs = N; i < n_blocks - 1; i++, ofs += N) {
        ms[i] = GB(N, ai + ofs, bi + ofs, ci + ofs, di + ofs);
        outs[i] = GB_up(N);
    }
    ms[n_blocks - 1] = GB(n_last, ai + ofs, bi + ofs, ci + ofs, di + ofs);
    outs[n_blocks - 1] = GB_up(n_last); // last block does not need outs

    /** **************** STEP 1 *******************/
    /** each block performs G_11..G_14 rotations **/
    /** the first block uses shift-through **/

    NT la0(1), lc0(1), la1, lc1;
    NT det0(1), denom0(1), det1, denom1, v12lc_exp(1);

    for(j = 0; j < m; j++) {
        v12lc_exp = v12lc_exp * v1lc;
    }

    for(j = 0; j < n_blocks-1; j++) {

// NOTE: can we merge the two stages to avoid ``stair-like'' updates ??
// NOTE: what is the best amount of redundant work to be assigned for
// each block ??
        for(i = j; i < n_blocks; i++) {
            // limit the number of iterations for the last block
            unsigned n_iters = (i < n_blocks - 1 ? N : n_last);
            gs = gs0;
            la1 = la0, lc1 = lc0;
            det1 = det0, denom1 = denom0;
            // j-th block performs update with shift-through
            schur_block(gs, ms[i], la1, lc1, det1, denom1, n_iters, (i == j),
                (GB_up *)0, &outs[i]);
//         if(j == 0) {
//             // block updating with shift-through is ready now
//             printf("\n########### block %d after update: %d %d", i, la1.x, lc1.x);
//             ms[i].print();
//         }
        }

        /** **************** STEP 2 *******************/
        /** each block except the first updates its ms[i] using 'outs' of the
            previous block **/
        for(i = j + 1; i < n_blocks; i++) {
            gs = gs0;
            la1 = la0, lc1 = lc0;
            det1 = det0, denom1 = denom0;
        // here we update y[8..11] using x[5..7] computed by ms0
        // NOTE: here we need to perform exactly N iters even if the last
        // block has smaller size because leading elements must be updated
        // exactly N-1 times
            schur_block(gs, ms[i], la1, lc1, det1, denom1, N, false,
                &outs[i - 1]);

        if(j == 0) {
        printf("\n########### block %d after update: %d %d", i, la0.x, lc0.x);
            ms[i].print();
        }
        }
        la0 = la1, lc0 = lc1; // update denominators for the next step
        det0 = det1, denom0 = denom1; // and determinant as well
        gs0 = ms[j]; // update leading block
    } // for(j)

    // it remains to run the last 2*N iterations by the last block with
    // shift-through from the previous one (should be merged in a single call)
    schur_block(ms[n_blocks-2], ms[n_blocks-1], la1, lc1, det1,
            denom1, N, true);

    printf("\n########### ms2 last iterations: \n");
    ms[n_blocks-1].print();

    // and finalize
    schur_block(ms[n_blocks-1], dummy, la1, lc1, det1, denom1, n_last, false);

    ms[n_blocks-1].print();

    NT inv(mod_inverse(denom1.x, zmod::modulus));
    det1 = det1 * v12lc_exp * inv;

    printf("determinant: %d\n", det1.x);
    return NT(0);
}

#define BLOCK_DEBUG 0

//! computes monic resultant, then multiplies it by v1lc^m * v2lc^n
//! \c v1/2lc - leading coefficients of the polynomials
//! \c failed : indicates if the algorithm computes zero denominator
template < class NT >
NT resultant_modular_sylvester_debug(const std::vector< NT >& v1,
        const std::vector< NT >& v2, bool& failed) {

    failed = false;
    unsigned n = v1.size()-1, m = v2.size()-1, r = n + m, i, j;

    zmod v1lc = v1[n];
    zmod inv1(mod_inverse(v1lc.x, zmod::modulus)), inv2(1);
    std::vector< NT > a(r, NT(0)), b(r, NT(0)), c(r, NT(0)), d(r, NT(0));

    // [a, b] = G; [c, d] = H
    a[0] = NT(1);
    b[m] = NT(0)-NT(1);

    for(i = 0; i < r; i++) {
        c[i] = (i <= n ? v1[n - i] * inv1 : NT(0));
        d[i] = (i <= m ? v2[m - i] * inv2 : NT(0));
        if(i >= m)
            d[i] = d[i] - v1[r - i] * inv1;

        b[i] = i*i;
    }

    NT la(1), lc(1), det(1), denom(1), v12lc_exp(1);
    j = 0;

#if 0
    for(j = 0; j < m; j++) {  // suppose m is even (at first)
        NT a0 = a[j], b0 = NT(0), c0 = c[j], d0 = d[j];

// if(j == 1) {
// printf("\nresultant_modular_sylvester: at iter: %d\n", j);
//     print_vector(a);
//     print_vector(b);
//     print_vector(c);
//     print_vector(d);
// printf("\n#################\n");
// }

        v12lc_exp = v12lc_exp * v1lc;
        for(i = j + 1; i < r; i++) {
            d[i] = (-c[i]*d0 + d[i]);
        }

        a[m] = d0; // b[m] == -1
        for(i = r - 2; (int)i >= (int)j; i--) {
            a[i + 1] = a[i]; // shiftdown
            c[i + 1] = c[i];
        }
        b[j] = 0, d[j] = 0;
        a[j] = 0; c[j] = 0;
    }
#else
    for(i = 0; i < m; i++) {
        v12lc_exp = v12lc_exp * v1lc;
    }
#endif

    for(; j < r; j++) {

    NT a0 = a[j], b0 = b[j], c0 = c[j], d0 = d[j];

if(j == 6) {
printf("\nresultant_modular_sylvester: at iter: %d\n", j);
    print_vector(a);
    print_vector(b);
    print_vector(c);
    print_vector(d);
printf("\n#################\n");
}

#if BLOCK_DEBUG
    const unsigned N = 6;
#else
    const unsigned N = 0;
#endif
    for(i = j; i < r - N; i++) {

        NT ai;
        ai = la*(a[i] * c0 - b[i]*d0);
        b[i] = lc*(-a[i]*b0 + b[i]*a0);
        a[i] = ai;

        NT ci = lc*(c[i]*a0 - d[i]*b0);
        d[i] = la*(-c[i]*d0 + d[i]*c0);
        c[i] = ci;
    }

#if BLOCK_DEBUG
printf("iter: %d: update: [%d; %d)\n", j, r - N + j, r);
    for(i = r - N + j; i < r; i++) {

        NT ai;
        ai = la*(a[i] * c0 - b[i]*d0);
        b[i] = lc*(-a[i]*b0 + b[i]*a0);
        a[i] = ai;

        NT ci = lc*(c[i]*a0 - d[i]*b0);
        d[i] = la*(-c[i]*d0 + d[i]*c0);
        c[i] = ci;
    }
#endif

    lc = la * lc * lc; la = a[j]; 
    det = det * c[j], denom = denom * lc;

    if(denom.x == 0) {
        printf("ill-conditioned matrix at j = %d\n", j);
        failed = true;
        return NT(0);
    }

    for(i = r - N - 2; (int)i >= (int)j; i--) {
        a[i + 1] = a[i]; // shiftdown
        c[i + 1] = c[i];
    }

#if BLOCK_DEBUG
    for(i = r - 2; (int)i >= (int)r - N + j; i--) {
        a[i + 1] = a[i]; // shiftdown
        c[i + 1] = c[i];
    }
#endif

    a[j] = 0; c[j] = 0;
    }

     det = det * v12lc_exp;

     NT inv(mod_inverse(denom.x, zmod::modulus));
     return NT(det * inv);
}

} // namespace internal

} // namespace CGAL

#endif // _BLOCK_UPDATES_GB_C_
