namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Classification
\cgalAutoToc
\author Simon Giraudot, Florent Lafarge

This component implements a generalization of the algorithm described in \cgalCite{cgal:lm-clscm-12}. It classifies a data set into a user-defined set of classification types, such as ground, vegetation and buildings. A flexible API is provided so that the user can classify any type of data, compute its own local attributes on the point cloud and define its own classification types based on these attributes.

\section Classification_Organization Package Organization

%Classification of data sets is achieved as follows:

- some analysis is performed on the input data set
- attributes are computed based on this analysis
- a set of classification types (for example: ground, building, vegetation) is defined by the user
- attributes are given weights and each pair of attribute/type is assigned a relationship
- classification is computed item-wise by minimizing an energy defined as the sum of the values taken by attributes on input items (which depend on the attribute/type relationship)
- additional regularization can be used by smoothing either locally or globally through an Alpha Expansion approach.

This package is designed to be easily extended by the user: more specifically, attributes and types can be defined by the user to handle any data he/she needs to classify (although \cgal provides a predefined framework for common urban scenes).

Currently, \cgal provides data structures to handle classification of point sets.

\cgalFigureBegin{Classification_Organization,organization.png}
Organization of the package.
\cgalFigureEnd

\section Classification_structures Data Structures

\subsection Classification_analysis Analysis

%Classification is based on the computation of local attributes. These attributes often require precomputed analysis structures: such data structures might be shared by several attributes and are therefore computed separately.

\cgal provides the following structures:

- [Point_set_neighborhood](@ref CGAL::Classification::Point_set_neighborhood) stores spatial searching structures and provides adapted queries for points
- [Local_eigen_analysis](@ref CGAL::Classification::Local_eigen_analysis) precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues
- [Planimetric_grid](@ref CGAL::Classification::Planimetric_grid) is a 2D grid used for digital terrain modeling.

The following code snippet shows how to instantiate such data structures from an input PLY point set (the full example is given at the end of the manual).

\snippet Classification/example_classifier.cpp Analysis

\subsection Classification_attributes Attributes

Attributes are defined as scalar fields that associate each input point with a specific value. The user may want to define its own attributes, especially if the input point set comes with additional properties that were not anticipated by \cgal.

A user-defined attribute must inherit from `CGAL::Classification::Attribute` and provide a method [value()](@ref CGAL::Classification::Attribute_base::value) that associate a scalar value to each input point.

Attributes are accessed through `Handle` objects, `CGAL::Classification::Attribute_handle`.

\cgal provides some predefined attributes that are relevant for classification of urban scenes:

- [Distance_to_plane](@ref CGAL::Classification::Attribute::Distance_to_plane) measures how far away a point is from a locally estimated plane
- [Elevation](@ref CGAL::Classification::Attribute::Elevation) computes the local distance to an estimation of the ground
- [Vertical_dispersion](@ref CGAL::Classification::Attribute::Vertical_dispersion) computes how noisy the point set is on a local Z-cylinder
- [Verticality](@ref CGAL::Classification::Attribute::Verticality) compares the local normal vector to the vertical vector.

For more details about how these different attributes can help identifying one classification type or the other, please refer to their associated reference manual pages. In addition, \cgal also provides attributes solely based on the local eigen values \cgalCite{cgal:mbrsh-raofw-11}. Such attributes are more theoretical and harder to relate to a specific use case, but they can help differenciating some classification types:

- [Anisotropy](@ref CGAL::Classification::Attribute::Anisotropy)
- [Eigentropy](@ref CGAL::Classification::Attribute::Eigentropy)
- [Linearity](@ref CGAL::Classification::Attribute::Linearity)
- [Omnivariance](@ref CGAL::Classification::Attribute::Omnivariance)
- [Planarity](@ref CGAL::Classification::Attribute::Planarity)
- [Sphericity](@ref CGAL::Classification::Attribute::Sphericity)
- [Sum_eigenvalues](@ref CGAL::Classification::Attribute::Sum_eigenvalues)
- [Surface_variation](@ref CGAL::Classification::Attribute::Surface_variation)

Finally, if the input point set has additional properties, these can also be used as attributes. For example, \cgal provides the following attributes:

- [Echo_scatter](@ref CGAL::Classification::Attribute::Echo_scatter) uses the number of returns (echo) provided by most LIDAR scanners if available
- [Hsv](@ref CGAL::Classification::Attribute::Hsv) uses input color information if available.

In the following code snippet, a subset of these attributes are instantiated, their weights are set and they are added to a newly created classifier:

\snippet Classification/example_classifier.cpp Attributes

\subsection Classification_types Classification Types

A classification type represents how a point should be classified, for example: vegetation, building, road, etc. It is defined by the values the attributes are expected to take for a specific type. For example, vegetation is expected to have a high distance to plane and have a color close to green (if colors are available); facades have a low distance to plane and a low verticality; etc.

\cgal provides a class `CGAL::Classification::Type` to define such a set of attribute effects, along with the associated `Handle` object: `CGAL::Classification::Type_handle`. Each type may define how a specific attribute affects it:

- [FAVORING](@ref CGAL::Classification::Attribute::FAVORING): the type is favored by high values of the attribute
- [NEUTRAL](@ref CGAL::Classification::Attribute::NEUTRAL): the type is not affected by the attribute
- [PENALIZING](@ref CGAL::Classification::Attribute::PENALIZING): the type is favored by low values of the attribute

Let \f$x=(x_i)_{i=1..N_c}\f$ be a potential classification result with \f$N_c\f$ the number of input points and \f$x_i\f$ the class of the \f$i^{th}\f$ point (for example: vegetation, ground, etc.). Let \f$a_j(i)\f$ be the raw value of the \f$j^{th}\f$ attribute at the \f$i^{th}\f$ point and \f$w_j\f$ be the weight of this attribute. We define the normalized value of the \f$j^{th}\f$ attribute at the \f$i^{th}\f$ point as follows:

\f{eqnarray*}{
    A_j(x_i) = & (1 - \min(\max(0,\frac{a_j(i)}{w_j}), 1)) & \mbox{if } a_j \mbox{ favors } x_i \\
    & 0.5 & \mbox{if } a_j \mbox{ is neutral for } x_i \\
    & \min(\max(0,\frac{a_j(i)}{w_j}), 1) & \mbox{if } a_j \mbox{ penalizes } x_i
\f}


The following code snippet shows how to add types to the classification object and how to set the effects of the attributes on these types:

\snippet Classification/example_classifier.cpp Classification Types

\subsection Classification_regularization Regularization

%Classification is performed by minizing an energy over the input point set that may include regularization. \cgal provides 3 different methods for classification, ranging from high speed / low quality to low speed / high quality:

- `CGAL::Classifier::run()` 
- `CGAL::Classifier::run_with_local_smoothing()`
- `CGAL::Classifier::run_with_graphcut()`

On a point set of 3 millions points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.

\cgalFigureBegin{Classification_image,classif.png}
Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (ground is orange, facades are blue, roofs are pink and vegetation is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.
\cgalFigureEnd


Mathematical details are provided hereafter.

\subsubsection Classification_regularized_no No Regularization

- `CGAL::Classifier::run()`: this is the fastest method
that provides acceptable but usually noisy results (see Figure
\cgalFigureRef{Classification_image}, top-right).

Let \f$x=(x_i)_{i=1..N_c}\f$ be a potential classification result with \f$N_c\f$ the number of input points and \f$x_i\f$ the class of the \f$i^{th}\f$ point (for example: vegetation, ground, etc.). The classification is performed by minimizing the following energy:

\f[
  E(x) = \sum_{i = 1..N_c} E_{di}(x_i)
\f]

This energy is a sum of pointwise energies and involves no regularization. Let \f$A=(A_j)_{j=1..N_a}\f$ be the set of normalized attributes
(see \ref Classification_types). The pointwise energy measures the coherence of the class \f$x_i\f$ at the \f$i^{th}\f$ point and is defined as:

\f[
  E_{di}(x_i) = \sum_{j = 1..N_a} A_j(x_i)
\f]



\subsubsection Classification_regularized_local Local Smoothing

- `CGAL::Classifier::run_with_local_smoothing()`: this
method is a tradeoff between quality and efficiency (see Figure
\cgalFigureRef{Classification_image}, bottom-left). The minimized
energy is defined as follows:


\f[
  E(x) = \sum_{i = 1..N_c} E_{si}(x_i)
\f]

The pointwise energy \f$E_{di}(x_i)\f$ is replaced by
\f$E_{si}(x_i)\f$ defined on a small local neighborhood \f$N(i)\f$ of
the \f$i^{th}\f$ point:

\f[
  E_{si}(x_i) = \sum_{j = 1..N_a} \frac{\sum_{k \in N(i)} A_j(x_k)}{\left| N(i) \right|}
\f]

This allows to eliminate local noisy variations of assigned
classification types. Increasing the size of the neighborhood
increases the noise reduction at the cost of higher computation times.


\subsubsection Classification_regularized_graphcut Global Regularization (Graph Cut)

- `CGAL::Classifier::run_with_graphcut()`: this method
offers the best quality but requires longer computation time (see
Figure \cgalFigureRef{Classification_image}, bottom-right). The
total energy that is minimized is the sum of the partial data term
\f$E_{di}(x_i)\f$ and of a pairwise interaction energy defined by the
standard Potts model \cgalCite{cgal:l-mrfmi-09} :

\f[
  E(x) = \sum_{i = 1..N_c} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j}
\f]

where \f$\gamma>0\f$ is the parameter of the Potts model that
quantifies the strengh of the regularization, \f$i \sim j\f$
represents the pairs of neighboring points and
\f$\mathbf{1}_{\{.\}}\f$ the characteristic function.

A Graph Cut based algorithm (Alpha Expansion) is used to quickly reach
an approximate solution close to the global optimum of this energy.

This method allows to consistently segment the input point set in
piecewise constant parts and to correct large wrongly classified
clusters. Increasing \f$\gamma\f$ produces more regular result with a
constant computation time.



\subsection Classification_example Example

The following example:

- reads an input file (LIDAR point set in PLY format)
- computes useful structures from this input
- computes segmentation attributes from the input and the precomputed structures
- defines 3 classification types (vegetation, ground and roof) along with the effects of attributes on them
- classifies the point set
- saves the result in a colored PLY format.

\cgalExample{Classification/example_classifier.cpp}

\section Classification_helper Helper

The classification algorithm is designed to be as flexible as possible: users may define their own attributes and classification types. Nevertheless, \cgal provides a predefined framework that should work correctly on common urban point sets. The class `CGAL::Point_set_classification` makes it easier for the user to classify its input point set:

- it takes care of generating all needed analysis structures
- it generates all possible attributes (among all the \cgal predefined ones) based on which property maps are available (it uses colors if available, etc.)
- multiple scales can be used to increase the quality of the results \cgalCite{cgal:hws-fsso3-16}
- input/ouput methods are provided to save and recover a specific configuration (with all attributes, types and relationships between them)
- classification can be saved as a PLY format with colors and labels.

\section Classification_training Training

%Classification is based on relationships between attributes and types. Each attribute has a specific weight and each pair of attribute/type has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 attributes are used to classify between 4 classification types, 30 parameters have to be set up.

Though it is possible to set them up one by one, \cgal also provides a training algorithm that requires a small set of ground truth points provided by the user. More specifically, the user must provide, for each classification type he/she wants to classify, a set of known inliers among the input point set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:

- for each attribute, a range of weights is tested: the effect each attribute have on each type is estimated. For a given weight, if an attribute has the same effect on each type, it is non-relevant for classification. The range of weights such that the attribute is relevant is estimated

- for each attribute, uniformly picked weight values are tested and their effects estimated

- each ground truth point provided by the user is classified using this set of weights and effects

- for each classification type, the ratio of correctly classified ground truth points is computed. The minimum of these ratios is used as a score for this set of weights and effects: a ratio of 0.8 means that for each classification type, at least 80\% of the provided ground truth point were correctly classified

- the same mechanism is repeated until all attributes' ranges have been tested. Weights are only changed one by one, the other ones kept to the previous value that gave the best score.

This usually converges to a satisfying solution. The number of trials is user defined, set to 300 by default. Using at least 10 times the number of attributes is advised. If the solution is not satisfying, more ground truth points can be selected,for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps the best weights found as initialization and carries on trying new weights by taking new ground truth points into account.

\cgalFigureBegin{Classification_training_fig,classif_training.png}
Example of evolution of training score. The purple curve is the score computed at the current iteration, green curve is the best score found so far. Iterations where better solutions are found are marked by vertical gray lines.
\cgalFigureEnd


\subsection Classification_helper_example Example with Helper and Training

The following example:

- reads a point set with a training set (embedded as a PLY attribute _label_)
- uses the helper to generate attributes on 5 scales
- trains the algorithm using 800 trials
- runs the algorithm using the graphcut regularization
- saves the output using the helper.

\cgalExample{Classification/example_point_set_classifier.cpp}

\section Classification_history History

This package is based on a research code by Florent Lafarge that was generalized, extended and packaged by Simon Giraudot.



*/
} /* namespace CGAL */
