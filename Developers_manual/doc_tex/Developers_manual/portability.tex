%% =============================================================================
%% The CGAL Developers' Manual
%% Chapter: Portability Issues
%% -----------------------------------------------------------------------------
%% file   : portability.tex
%% authors: Michael Hoffmann <hoffmann@inf.ethz.ch> &
%%          Stefan Schirra <stschirr@mpi-sb.mpg.de>
%% -----------------------------------------------------------------------------
%% $Id$
%% $Date$
%% =============================================================================

\chapter{Portability Issues\label{chap:portability}}
\ccChapterRelease{Chapter Version: 1.0}
\ccChapterAuthor{Michael Hoffmann ({\tt hoffmann@inf.ethz.ch})\\
                 Stefan Schirra\\
                 Sylvain Pion}
\ccIndexMainItemBegin{portability}

This chapter gives an overview of issues related to the
configuration of \cgal\ that allow you to answer such questions as:
\begin{itemize}
\item Is \leda/\textsc{Gmp} there? (Section~\ref{sec:leda_gmp_support})
\item Which compiler is this? (Section~\ref{sec:which_compiler})
\item Does the compiler support feature X? (Section~\ref{sec:workaround_flags})
\end{itemize}

Also addressed here are issues related to writing code for 
non-standard-compliant compilers.  Compilers have made a lot of progress toward 
the \CC-standard recently.  But still they do not fully implement it. There 
are a few features you may assume; others you may not
assume. Especially you may assume that the compiler
\begin{itemize}
\item supports namespaces
\item supports member templates
\item support for \texttt{std::iterator\_traits}.
\end{itemize}
Still, there are many bugs (sometimes known as ``features'') left in the 
compilers.  Have a look at the list of (non-obsolete) workarounds in 
Section~\ref{sec:workaround_flags} to get an idea of which ``features'' are
still present.  

\ccIndexMainItemBegin{configuration}
\section{Checking for \leda\ or GMP support\label{sec:leda_gmp_support}}
\ccIndexSubsubitem{\leda}{support}{checking for}
%\index{leda support@\leda\ support!checking for}
\index{gmp support@GMP support!checking for}

In the makefiles included for the compilation of every \cgal\ program
(\ie, those to which the environment variable {\tt CGAL\_MAKEFILE} refers),
\ccIndexSubitem{\tt makefile}{\cgal}
\index{CGAL_MAKEFILE variable@{\tt CGAL\_MAKEFILE} variable}
we define command line switches that set the flags 
\begin{verbatim}
CGAL_USE_LEDA, CGAL_USE_GMP
\end{verbatim}
\index{CGAL_USE_LEDA flag@{\tt CGAL\_USE\_LEDA} flag}
\index{flag!for \leda}
\index{CGAL_USE_GMP flag@{\tt CGAL\_USE\_GMP} flag}
\index{flag!for GMP}
iff \cgal\ is configured with \leda\ or GMP support, respectively.

\section{Using Boost\label{sec:boost_support}}
\cgal\ code can rely on Boost libraries to some extent.

Boost was shipped with \cgal\ Release 3.1, and is no longer
shipped within \cgal, as it is mainstream, and already distributed
with Linux and Cygwin.  

Since portability and backward compatibility are a concern in \cgal,
we have decided that the list of Boost libraries usable in \cgal\ will be
decided by the \cgal\ editorial board.  The requirements are higher
when it appears in the user visible interface than when Boost code
is used only internally.  Requirements are even lower for code that
is not released such as the test-suite.  Boost libraries already accepted
in the C++ Standard Library Technical Report will be the first easy
candidates (these are marked \texttt{[TR1]} in the list below).

Finally, the policy is that if a better alternative exists in Boost and is
allowed, then \cgal\ code must use it instead of a \cgal\ version (which
probably must be deprecated and phased out), trying not to break backward
compatibility too much.


\section{Using the version-number and configuration macros and flags\label{sec:using_version_macros}}
\index{LEDA macro@{\tt \_\_LEDA\_\_} macro!using}
\index{CGAL_USE_LEDA flag@{\tt CGAL\_USE\_LEDA} flag!using}
\index{CGAL_USE_GMP flag@{\tt CGAL\_USE\_GMP} flag!using}

Here is a short example on how these macros can be used. Assume you have some
piece of code that depends on whether you have \leda-4.0 or later.
\begin{verbatim}
#ifdef CGAL_USE_LEDA
#include <LEDA/basic.h>
#endif

#if defined(CGAL_USE_LEDA) && __LEDA__ >= 400
... put your code for LEDA 4.0 or later ...
#else
... put your code for the other case ...
#endif 
\end{verbatim}

\section{Identifying compilers and architectures\label{sec:which_compiler}}
\ccIndexSubitem{compilers}{identifying}
\ccIndexSubitem{macros}{for compiler identification}
\ccIndexSubitem{flag}{for compiler}

Every compiler defines some macros that allow you to identify it; see 
the following table.

\vspace{5mm}\fbox{\begin{tabular}{lll}
GNU 3.2.1       & \texttt{\_\_GNUC\_\_}             & 3\\
GNU 3.2.1       & \texttt{\_\_GNUC\_MINOR\_\_}      & 2\\
GNU 3.2.1       & \texttt{\_\_GNUC\_PATCHLEVEL\_\_} & 1\\
Microsoft VC7.1 & \texttt{\_MSC\_VER}               & 1310\\
Microsoft VC8.0 & \texttt{\_MSC\_VER}               & 1400\\
Intel 11.1      & \texttt{\_\_INTEL\_COMPILER}      & 1110\\
Clang 2.9       & \texttt{\_\_clang\_major\_\_}     & 2\\
Clang 2.9       & \texttt{\_\_clang\_minor\_\_}     & 9\\
SUN 5.3         & \texttt{\_\_SUNPRO\_CC}           & 0x530\\
SUN 5.10        & \texttt{\_\_SUNPRO\_CC}           & 0x5100\\
\end{tabular}}\vspace{5mm}

\noindent There are also flags to identify the architecture.
\ccIndexSubitem{architecture}{identifying}
\ccIndexSubitem{macros}{for architecture identification}
\ccIndexSubitem{flag}{for architecture}

\vspace{5mm}\fbox{\begin{tabular}{lll}
    SGI   & \texttt{\_\_sgi}\\
    SUN   & \texttt{\_\_sun}\\
    Linux & \texttt{\_\_linux}\\
\end{tabular}}\vspace{5mm}

\section{Known problems and workarounds\label{sec:problems_and_workarounds}}

For (good) reasons that will not be discussed here, it was decided to
use \CC\ for the development of \cgal. An international standard for
\CC\ has been sanctioned in 1998 \cite{cgal:ansi-is14882-98} and the
level of compliance varies widely between different
compilers\index{C++ standard@\CC\ standard}, let alone bugs.

\subsection{Workaround flags\label{sec:workaround_flags}}
\ccIndexMainItemBegin{workaround flags}

In order to provide a uniform development environment for \cgal\ that
looks more standard compliant than what the compilers provide, a number
of workaround flags and macros have been created.  Some of the
workaround macros are set in \ccAnchor{http://www.cgal.org/Manual/include/CGAL/config.h}{\texttt{<CGAL/config.h>}}
\ccIndexMainItem{\tt config.h}
using the macros 
listed in Section~\ref{sec:which_compiler} to identify the compiler. 
But most of them are set in the platform-specific configuration files
\ccIndexSubitem{configuration}{file}
\begin{center}
\texttt{<CGAL/config/}{\em os-compiler}\texttt{/CGAL/compiler\_config.h>}
\end{center}
where \textit{os-compiler} refers to a string describing your
operating system and compiler that is defined as follows.
\ccIndexSubitemBegin{flag}{for OS \& compiler}

\begin{center}
  \textit{$<$arch$>$\texttt{\_}$<$os$>$\texttt{-}$<$os-version$>$\texttt{\_}$<$comp$>${\tt
      -}$<$comp-version$>$}
\end{center}

\begin{description}
\item[$<$arch$>$] is the system architecture as defined by ``{\tt
    uname -p}'' or ``\texttt{uname -m}'',
\item[$<$os$>$] is the operating system as defined by ``\texttt{uname
    -s}'',
\item[$<$os-version$>$] is the operating system version as defined by
  ``\texttt{uname -r}'',
\item[$<$comp$>$] is the basename of the compiler executable (if it
  contains spaces, these are replaced by "-"), and
\item[$<$comp-version$>$] is the compiler's version number (which
  unfortunately can not be derived in a uniform manner, since it is
  quite compiler specific).
\end{description}

\noindent Examples are \texttt{mips\_IRIX64-6.5\_CC-n32-7.30} or {\tt
  sparc\_SunOS-5.6\_g++-2.95}. For more information, see the \cgal\ 
\ccAnchor{http://www.cgal.org/Manual/doc_html/installation/contents.html}{installation guide}.
\ccIndexSubitemEnd{flag}{for OS \& compiler}

This platform-specific configuration file is created during
\ccIndexSubsubitem{configuration}{file}{creation}
\ccIndexMainItem{installation}
installation by the script \texttt{install\_cgal}. The flags listed below
are set according to the results of test programs that are compiled and run.
These test programs reside in the directory
\begin{center}
\verb|$(CGAL_ROOT)/config/testfiles|
\end{center}
where \verb|$(CGAL_ROOT)| represents the installation directory for the library.
The names of all testfiles, which correspond to the names of the flags, 
\ccIndexSubitem{workaround flags}{names}
start with ``\texttt{CGAL\_CFG\_}'' followed by
\begin{itemize}
\item \textit{either} a description of a bug ending with
  ``\texttt{\_BUG}''
\item \textit{or} a description of a feature starting with
  ``\texttt{NO\_}''.
\end{itemize}
For any of these files a corresponding flag is set in the 
platform-specific configuration file, iff either compilation or execution
fails. The reasoning behind this sort of negative scheme is that on
standard-compliant platforms there should be no flags at all.

\noindent Currently (CGAL-3.4-I-181), we have the following configuration
test files (and flags). The short descriptions that are given in the files are 
included here. In some cases, it is probably necessary to have a look at the
actual files to understand what the flag is for. This list is just to
give an overview.  See the section on
\ccAnchor{http://www.cgal.org/Manual/doc_html/installation/Chapter_installation.html#Section_17}{troubleshooting} in the installation guide
for more explanation of some of these problems and known workarounds. 
Be sure to have a look at \texttt{Installation/config/testfiles/} to have an
up-to-date version of this list.

\begin{description}
\item[{\tt CGAL\_CFG\_LONGNAME\_BUG}]~\\
 \ccIndexMainItem{long-name problem} %
 \ccIndexSubitem{compiler bugs}{long symbol names} %
 This flag is set if a compiler (or assembler or linker) has problems 
 with long symbol names. 

\item[{\tt CGAL\_CFG\_NET2003\_MATCHING\_BUG}]~\\
 \ccIndexSubitem{matching}{member functions} %
 \ccIndexSubitem{compiler bugs}{member functions} %
 This flag is set, if the compiler does not match a member definition
 to an existing declaration. This bug shows up on VC~7.1~Beta
 (\ccc{cl1310}).

\item[{\tt CGAL\_CFG\_NO\_LIMITS}]~\\
  \ccIndexMainItem{limits} %
  This flag is set if a compiler does not know the limits.

\item[{\tt CGAL\_CFG\_NO\_LONG\_LONG}]~\\
  \index{long long@{\tt long long}} %
  The \ccc{long long} built-in integral type is not part of the
  \textsc{Iso} C++ standard, but many compilers support it
  nevertheless, since it is part of the \textsc{Iso} C standard. This
  flag is set if it is supported.
  
\item[{\tt CGAL\_CFG\_NO\_TMPL\_IN\_TMPL\_PARAM}]~\\
  \ccIndexSubitem{compiler bugs}{template parameters} %
  \ccIndexSubitem{template}{template parameter} %
  Nested templates in template parameter, such as ``\texttt{template <
    template <class T> class A>}'' are not supported by any compiler.
  This flag is set if they are not supported.

\end{description}
\ccIndexMainItemEnd{workaround flags}

\subsection{Macros connected to workarounds/compilers\label{sec:workaround_macros}}
\ccIndexSubitemBegin{macros}{for workarounds}

Some macros are defined according to certain workaround flags. This is
done to avoid some \texttt{\#ifdef}s in our actual code.

\begin{description}
\item[\texttt{CGAL\_LITTLE\_ENDIAN}] set, iff
 \index{cgal_little_endian macro@\texttt{CGAL\_LITTLE\_ENDIAN} macro}
  \ccIndexMainItem{little-endian}
  {\texttt{CGAL\_CFG\_NO\_BIG\_ENDIAN}} is set.
\item[\texttt{CGAL\_BIG\_ENDIAN}] set, iff
 \index{cgal_big_endian macro@\texttt{CGAL\_BIG\_ENDIAN} macro}
  \ccIndexMainItem{big-endian}
  {\texttt{CGAL\_CFG\_NO\_BIG\_ENDIAN}} is not set.

\item[\texttt{CGAL\_DEPRECATED}]
 \index{cgal_deprecated macro@\texttt{CGAL\_DEPRECATED} macro}
  \ccIndexMainItem{deprecated}
  used to declare a function as deprecated --- just add it before the
  function declaration.  You may also surround deprecated code with
  \texttt{CGAL\_NO\_DEPRECATED\_CODE}, such that it is easy to test
  if a piece of code uses deprecated code or not:
\begin{verbatim}
#ifndef CGAL_NO_DEPRECATED_CODE
CGAL_DEPRECATED void foo(int i)
{
 ...
}
#endif // CGAL_NO_DEPRECATED_CODE
\end{verbatim}
\end{description}
\ccIndexSubitemEnd{macros}{for workarounds}


\subsection{Various other problems and solutions\label{sec:various_problems}}

\begin{description}
\item[\textbf{min and max}]
Visual \CC\ headers (and others) sometimes define \ccc{min} and \ccc{max} as macros. If you write \ccc{max} followed by an opening parenthesis, this can lead to unwanted substitutions. In order to work around it, you should use one of the following tricks:
\begin{verbatim}
  max BOOST_PREVENT_MACRO_SUBSTITUTION (a, b);
  (max) (a, b);
\end{verbatim}

\item[\textbf{Templated member functions}]

For SunPRO \CC\, member function templates with dependent return type
must be defined in the body of the class. 

\item[\textbf{Function parameter matching}]

The function parameter matching capacities of Visual \CC are rather limited. 
Failures occur when your function \ccc{bar} is like
\begin{verbatim}
  bar(std::some_iterator<std::some_container<T>>....) ...
  ...
  bar(std::some_iterator<std::some_other_container<T>>....) ...
\end{verbatim}
VC++ fails to distinguish that these parameters have different types.
A workaround is to add some dummy parameters that are defaulted to
certain values, and this affects only the places where the functions
are defined, not the places where they are called.
This may not be true anymore for recent VC++ versions.

\item[\textbf{typedefs of derived classes}]
Microsoft VC++ does not like the following sorts of typedefs that are 
standard
\begin{verbatim}
class A : public B::C {
        typedef B::C C;
};
\end{verbatim}
It says that the typedef is "redefinition".  So such typedefs should be 
enclosed by
\begin{verbatim}
#ifndef _MSC_VER

#endif
\end{verbatim}
This may not be true anymore for recent VC++ versions.
\end{description}

\ccIndexMainItemEnd{configuration}

\section{Requirements and recommendations\label{sec:portability_req_and_rec}}

\noindent
Recommendations:
\begin{itemize}
\item Workarounds for a compiler bug or a missing feature should not
      be treated on a per-compiler basis. When you detect a deficiency,
      you should rather write a short test program that triggers the setting
      of a flag for this deficiency during configuration.
\end{itemize}

\ccIndexMainItemEnd{portability}
