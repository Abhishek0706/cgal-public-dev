% +------------------------------------------------------------------------+
% | Reference manual page: Delaunay_triangulation_3.tex
% +------------------------------------------------------------------------+
% | 27.3.2000   Monique Teillaud
% | Package: Triangulation3
% | 
\RCSdef{\RCSDelaunaytriangulationRev}{$Id$}
\RCSdefDate{\RCSDelaunaytriangulationDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Delaunay_triangulation_3<DelaunayTriangulationTraits_3,TriangulationDataStructure_3,LocationPolicy>}

\ccDefinition
  
The class \ccc{Delaunay_triangulation_3} represents a three-dimensional
Delaunay triangulation.

\ccInclude{CGAL/Delaunay_triangulation_3.h}

\ccParameters

The first template argument must be a model of the
\ccc{DelaunayTriangulationTraits_3} concept.

The second template argument must be a model of the
\ccc{TriangulationDataStructure_3} concept.
It has the default value \ccc{Triangulation_data_structure_3<Triangulation_vertex_base_3<DelaunayTriangulationTraits_3>, Triangulation_cell_base_3<DelaunayTriangulationTraits_3> >}.

The third template argument is a tag which must be a \ccc{Location_policy<Tag>} :
either \ccc{Fast_location} or \ccc{Compact_location}.
\ccc{Fast_location} offers faster ($O(\log n)$ time) point
location, which can be beneficial when performing point locations or random
point insertions (with no good location hint) in large data sets.
It is currently implemented using an additional triangulation
hierarchy data structure~\cite{cgal:d-dh-02}.
The default is \ccc{Compact_location}, which saves memory (3-5\%) by avoiding the need for this
separate data structure, and point location is then performed roughly in
$O(n^{1/3})$ time.
Note that this argument can also come in second position, which can be useful when
the default value for the \ccc{TriangulationDataStructure_3} parameter is
satisfactory (this is using so-called deduced parameters).
Note that this argument replaces the functionality
provided before \cgal\ 3.6 by \ccc{Triangulation_hierarchy_3}.
An example of use can be found in the user
manual~\ref{Triangulation3-ex-fast-location}.


\ccInheritsFrom{\ccc{Triangulation_3<DelaunayTriangulationTraits_3,Delaunay_triangulation_3<DelaunayTriangulationTraits_3,TriangulationDataStructure_3,LocationPolicy>::Triangulation_data_structure >}}

\ccTypes

\ccThree{typedef DelaunayTriangulationTraits_3::Object_3 Object;}{}
\ccThreeToTwo

\ccTypedef{typedef LocationPolicy Location_policy;}{}

In addition to those inherited, the following types are defined, for use by the
construction of the Voronoi diagram:

\ccTypedef{typedef DelaunayTriangulationTraits_3::Line_3 Line;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Ray_3 Ray;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Plane_3 Plane;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Object_3 Object;}{}

\ccCreation
\ccCreationVariable{dt}
\ccThree{OutputIterator}{dt.remove(Point p)toto}{}

\ccConstructor{Delaunay_triangulation_3
(const DelaunayTriangulationTraits_3& traits = DelaunayTriangulationTraits_3())}
{Creates an empty Delaunay triangulation, possibly specifying a traits class
\ccc{traits}.}

\ccConstructor{Delaunay_triangulation_3 (const Delaunay_triangulation_3 & dt1)}
{Copy constructor.}

\ccConstructor{template < class InputIterator >
       Delaunay_triangulation_3 (InputIterator first, InputIterator last,
 const DelaunayTriangulationTraits_3& traits = DelaunayTriangulationTraits_3())}
{Equivalent to constructing an empty triangulation with the optional 
traits class argument and calling \ccc{insert(first,last)}.}

\ccOperations

\ccHeading{Insertion}

The following methods overload the corresponding methods of
triangulations to ensure the empty sphere property of Delaunay 
triangulations.

In the degenerate case when there are co-spherical points, the Delaunay
triangulation is known not to be uniquely defined. In this case, \cgal\ 
chooses a particular Delaunay triangulation using a symbolic perturbation
scheme~\cite{cgal:dt-pvr3d-03}.

\ccThree{OutputIterator}{dt.remove()}{}

\ccMethod{Vertex_handle insert(const Point & p,
                               Cell_handle start = Cell_handle() );}
{Inserts point \ccc{p} in the triangulation and returns the corresponding
 vertex. Similar to the insertion in a triangulation, but ensures in
addition the empty sphere property of all the created faces.
The optional argument \ccc{start} is used as a starting place for the search.}

\ccMethod{Vertex_handle insert(const Point & p, Vertex_handle hint);}
{ Same as above but uses \ccc{hint} as a starting place for the search. }

\ccMethod{Vertex_handle insert(const Point & p, Locate_type lt,
                               Cell_handle loc, int li, int lj);}
{Inserts point \ccc{p} in the triangulation and returns the corresponding
 vertex. Similar to the above \ccc{insert()} function, but takes as additional
 parameter the return values of a previous location query.  See description of
 \ccc{Triangulation_3::locate()}.}

The following method allows one to insert several points. It returns the
number of inserted points. 


\ccMethod{template < class PointInputIterator >
          std::ptrdiff_t
          insert(PointInputIterator first, PointInputIterator last);}
{Inserts the points in the iterator range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$.  Returns the number of inserted points.
Note that this function is not guaranteed to insert the points
following the order of \ccc{PointInputIterator}, as \ccc{spatial_sort}
is used to improve efficiency.
\ccPrecond{The \ccc{value_type} of \ccc{first} and \ccc{last} is
\ccc{Point}. }
}


\ccMethod{template < class PointWithInfoInputIterator >
          std::ptrdiff_t
          insert(PointWithInfoInputIterator first, PointWithInfoInputIterator last);}
{
Inserts the points in the iterator range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$.  Returns the number of inserted points.
Note that this function is not guaranteed to insert the points
following the order of \ccc{PointWithInfoInputIterator}, as \ccc{spatial_sort}
is used to improve efficiency.
Given a pair \ccc{(p,i)},  the vertex \ccc{v} storing \ccc{p} also stores \ccc{i}, that is 
\ccc{v.point() == p} and \ccc{v.info() == i}. If several pairs have the same point, 
only one vertex is created, and one of the objects of type \ccc{Vertex::Info} will be stored in the vertex.
\ccPrecond{\ccc{Vertex} must be model of the concept \ccc{TriangulationVertexBaseWithInfo_3}.
The \ccc{value_type} of \ccc{first} and \ccc{last} is \ccc{std::pair<Point,Vertex::Info>}.}
}



\ccHeading{Displacement}

\ccMethod{Vertex_handle    move_if_no_collision(Vertex_handle v, const Point & p);}
{ if there is not already another vertex placed on \ccc{p}, 
the triangulation is modified such that the new position of vertex \ccc{v}
is \ccc{p}, and \ccc{v} is returned. Otherwise, the triangulation is not
modified and the vertex at point \ccc{p} is returned.
\ccPrecond Vertex \ccc{v} must be finite.}

\ccMethod{Vertex_handle    move(Vertex_handle v, const Point & p);}
{same as above if there is no collision. Otherwise, \ccc{v}
is deleted and the vertex placed on \ccc{p} is returned.
 \ccPrecond Vertex \ccc{v} must be finite.}

\ccHeading{Removal}

When a vertex \ccc{v} is removed from a triangulation, all the cells
incident to \ccc{v} must be removed, and the polyhedral region
consisting of all the tetrahedra that are incident to \ccc{v} must be
re-triangulated. 
So, the problem reduces to triangulating a polyhedral
region, while preserving its boundary, or to compute a
\textit{constrained} triangulation. This is known to be sometimes
impossible: the Sch\"onhardt polyhedron cannot be triangulated
\cite{cgal:s-cgehd-98}. 

However, when dealing with Delaunay triangulations, the case of such
polyhedra that cannot be re-triangulated cannot happen, so \cgal\
proposes a vertex removal.

\ccMethod{void remove(Vertex_handle v);}
{Removes the vertex \ccc{v} from the triangulation.
\ccPrecond{\ccc{v} is a finite vertex of the triangulation.}}

\ccMethod{template < typename InputIterator >
          int remove(InputIterator first, InputIterator beyond);}
{Removes the vertices specified by the iterator range [\ccStyle{first, beyond})
of value type \ccc{Vertex_handle}.
\ccc{remove()} is called over each element of the range.
The number of vertices removed is returned.
\ccPrecond{(i) all vertices of the range are finite vertices of the triangulation; and (ii) no vertices are repeated in the range.}}

\ccMethod{template < typename InputIterator >
          int remove_cluster(InputIterator first, InputIterator beyond);}
{This function has exactly the same result and the same preconditions as \ccc{remove(first, beyond)}.
The difference is in the implementation and efficiency. This version does not re-triangulate the hole after each
point removal but only after removing all vertices. This is more efficient if (and only if) the removed points
are organized in a small number of connected components of the Delaunay triangulation.}

If, due to some point removals, the size of the Delaunay triangulation decreases drastically, it might be interesting to defragment the 
\ccc{CGAL::Compact_container} (used by the \ccc{Triangulation_data_structure_3}).

\ccHeading{Queries}

\ccMethod{Bounded_side
          side_of_sphere(Cell_handle c, const Point & p) const;}
{Returns a value indicating on which side of the circumscribed sphere
of \ccc{c} the point \ccc{p} lies. More precisely, it returns:\\
- \ccc{ON_BOUNDED_SIDE} if \ccc{p} is inside the sphere. For an infinite
cell this means that \ccc{p} lies strictly either in the half space
limited by its finite facet and not containing any other point of the
triangulation, or in the interior of the disk circumscribing the
\textit{finite} facet. \\ 
- \ccc{ON_BOUNDARY} if p on the boundary of the sphere. For an infinite
cell this means that \ccc{p} lies on the circle circumscribing
the \textit{finite} facet.\\ 
- \ccc{ON_UNBOUNDED_SIDE} if \ccc{p} lies outside the sphere. For an
infinite cell this means that \ccc{p} does not satisfy either of the
two previous conditions. 
\ccPrecond{\ccVar.\ccc{dimension()} $=3$.}}
\ccMethod{Bounded_side
          side_of_circle(const Facet & f, const Point & p) const;}
{Returns a value indicating on which side of the circumscribed circle
of \ccc{f} the point \ccc{p} lies. More precisely, it returns:\\
- in dimension~3:\\
-- For a finite facet, \ccc{ON_BOUNDARY} if \ccc{p} lies
on the circle, \ccc{ON_UNBOUNDED_SIDE} when it lies in the exterior of
the disk, \ccc{ON_BOUNDED_SIDE} when it lies in its interior.\\
-- For an infinite facet, it considers the plane defined by the finite
facet of the same cell, and does the same as in dimension~2 in this
plane.\\
- in dimension~2:\\
-- For a finite facet, \ccc{ON_BOUNDARY} if \ccc{p} lies
on the circle, \ccc{ON_UNBOUNDED_SIDE} when it lies in the exterior of
the disk, \ccc{ON_BOUNDED_SIDE} when it lies in its interior.\\
-- For an infinite facet, \ccc{ON_BOUNDARY} if the
point lies on the finite edge of \ccc{f} (endpoints included),
\ccc{ON_BOUNDED_SIDE} for a point in the open half plane defined
by \ccc{f} and not containing any other point of the triangulation,
\ccc{ON_UNBOUNDED_SIDE} elsewhere. 
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$ and in dimension 3,
\ccc{p} is coplanar with \ccc{f}.}}

\ccMethod{Bounded_side
          side_of_circle(Cell_handle c, int i, const Point & p);}
{Same as the previous method for facet \ccc{i} of cell \ccc{c}.}

\ccMethod{Vertex_handle nearest_vertex(Point p,
                                       Cell_handle c = Cell_handle());}
{Returns any nearest vertex to the point \ccc{p}, or the default constructed
handle if the triangulation is empty.  The optional argument \ccc{c} is a hint
specifying where to start the search.
\ccPrecond{\ccc{c} is a cell of \ccVar.}
}

\ccMethod{Vertex_handle nearest_vertex_in_cell(Point p,
                                       Cell_handle c);}
{Returns the  vertex  of the cell \ccc{c} that is
nearest to $p$.
}

A point \ccc{p} is said to be in conflict with a cell \ccc{c} in dimension 3
(resp. a facet \ccc{f} in dimension 2) iff \ccVar.\ccc{side_of_sphere(c, p)}
(resp. \ccVar.\ccc{side_of_circle(f, p)}) returns \ccc{ON_BOUNDED_SIDE}.
The set of cells (resp. facets in dimension 2) which are in conflict with
\ccc{p} is connected, and it forms a hole.

\ccMethod{template <class OutputIteratorBoundaryFacets,
                    class OutputIteratorCells>
  std::pair<OutputIteratorBoundaryFacets, OutputIteratorCells>
  find_conflicts(Point p, Cell_handle c,
                 OutputIteratorBoundaryFacets bfit,
                 OutputIteratorCells cit);}
{Computes the  conflict hole induced by \ccc{p}.  The starting cell
(resp.  facet) \ccc{c} must be in conflict.  Then this function returns
respectively in the output iterators:\\
-- \ccc{cit}: the cells (resp. facets) in conflict.\\
-- \ccc{bfit}: the facets (resp. edges) on the boundary, that is, the facets
(resp. edges) \ccc{(t, i)} where the cell (resp. facet) \ccc{t} is in
conflict, but \ccc{t->neighbor(i)} is not.\\
This function can be used in conjunction with \ccc{insert_in_hole()} in order
to decide the insertion of a point after seeing which elements of the
triangulation are affected.
Returns the pair composed of the resulting output iterators.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}

\ccMethod{template <class OutputIteratorBoundaryFacets,
                    class OutputIteratorCells,
                    class OutputIteratorInternalFacets>
  Triple<OutputIteratorBoundaryFacets,
         OutputIteratorCells,
         OutputIteratorInternalFacets>
  find_conflicts(Point p, Cell_handle c,
                 OutputIteratorBoundaryFacets bfit,
                 OutputIteratorCells cit,
                 OutputIteratorInternalFacets ifit);}
{Same as the other \ccc{find_conflicts()} function, except that it also 
computes the internal facets, i.e. the facets common to two cells which
are in conflict with \ccc{p}.
Then this function returns respectively in the output iterators:\\
-- \ccc{cit}: the cells (resp. facets) in conflict.\\
-- \ccc{bfit}: the facets (resp. edges) on the boundary, that is, the facets
(resp. edges) \ccc{(t, i)} where the cell (resp. facet) \ccc{t} is in
conflict, but \ccc{t->neighbor(i)} is not.\\
-- \ccc{ifit}: the facets (resp. edges) inside the hole, that is, delimiting
two cells (resp facets) in conflict.\\
Returns the \ccc{Triple} composed of the resulting output iterators.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}

\begin{ccDeprecated}
\ccMethod{template <class OutputIterator>
  OutputIterator
  vertices_in_conflict(Point p, Cell_handle c,
                       OutputIterator res);}
{This function is renamed \ccc{vertices_on_conflict_zone_boundary} since CGAL-3.8.}
\end{ccDeprecated}
\ccMethod{template <class OutputIterator>
  OutputIterator
  vertices_on_conflict_zone_boundary(Point p, Cell_handle c,
                                     OutputIterator res);}
{Similar to \ccc{find_conflicts()}, but reports the vertices which are on the
boundary of the conflict hole of \ccc{p}, in the output iterator \ccc{res}.
Returns the resulting output iterator.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}

A face (cell, facet or edge) is said to be a Gabriel face iff
its   smallest circumscribing sphere do not enclose
any vertex of the triangulation.  Any Gabriel face belongs to the
Delaunay triangulation, but the reciprocal is not true.
The following member functions test the Gabriel property of
Delaunay faces.
\ccMethod{bool is_Gabriel(Cell_handle c, int i);}{}
\ccGlue 
\ccMethod{bool is_Gabriel(Cell_handle c, int i, int j);}{}
\ccGlue 
\ccMethod{bool is_Gabriel(const Facet& f);}{}
\ccGlue
\ccMethod{bool is_Gabriel(const Edge& e);} {}


\ccHeading{Voronoi diagram}
\ccIndexMainItem{Voronoi diagram}
\cgal\ offers several functionalities to display the Voronoi diagram of 
a set of points in 3D.

Note that the user should use a kernel with exact constructions in order
to guarantee the computation of the Voronoi diagram (as opposed to computing
the triangulation only, which requires only exact predicates).

\ccMethod{Point dual(Cell_handle c) const;}
{Returns the circumcenter of the four vertices of c.
\ccPrecond{\ccVar.\ccc{dimension()}$=3$ and \ccc{c} is not infinite.}}

\ccMethod{Object dual(Facet f) const;}
{Returns the dual of facet \ccc{f}, which is \\
in dimension 3: either a segment, if the two cells incident to \ccc{f}  
are finite, or a ray, if one of them is infinite;\\
in dimension 2: a point.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$ and \ccc{f} is not infinite.}}

\ccMethod{Object dual(Cell_handle c, int i) const;}
{same as the previous method for facet \ccc{(c,i)}.}

\ccMethod{Line dual_support(Cell_handle c, int i) const;}
{returns the line supporting the dual of the facet.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$ and \ccc{f} is not infinite.}}

\ccMethod{template <class Stream> Stream & draw_dual(Stream & os);}
{Sends the set of duals to all the facets of \ccVar\ into \ccc{os}.}


\begin{ccDebug}
\ccHeading{Checking}
\ccMethod{bool
          is_valid(bool verbose = false) const;}
{Checks the combinatorial validity of the triangulation and the
validity of its geometric embedding (see
Section~\ref{Triangulation3-sec-intro}). Also checks that all the
circumscribing spheres (resp. circles in dimension~2) of  cells
(resp. facets in dimension~2) are empty.\\ When \ccc{verbose} is set to
true,  messages describing the first invalidity encountered are
printed.}

\ccMethod{bool
          is_valid(Cell_handle c, bool verbose = false) const;}
{Checks the combinatorial and geometric validity of the cell (see
Section~\ref{Triangulation3-sec-intro}). Also checks that the
circumscribing sphere (resp. circle in dimension~2) of  cells
(resp. facet in dimension~2) is empty.\\
 When \ccc{verbose} is set to
true, messages are printed to give
a precise indication of the kind of invalidity encountered.}

These methods are  mainly a debugging help for the users of advanced features.
\end{ccDebug}

\ccSeeAlso

\ccc{CGAL::Regular_triangulation_3}

\end{ccRefClass}
