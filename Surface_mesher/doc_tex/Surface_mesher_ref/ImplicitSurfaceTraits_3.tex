% +------------------------------------------------------------------------+
% | Reference manual page: ImplicitSurfaceTraits_3.tex
% +------------------------------------------------------------------------+
% | 18.01.2006   Laurent Rineau
% | Package: Surface_mesher
% | 
\RCSdef{\RCSImplicitSurfaceTraitsRev}{$Id$}
\RCSdefDate{\RCSImplicitSurfaceTraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{ImplicitSurfaceTraits_3}

\ccDefinition
  
The concept \ccRefName\  describes the requirements of the traits class to
be plugged  as \ccc{Traits} in \ccc{Implicit_surface_3<Traits,
Function>}.


When \ccc{make_surface_mesh} is called
with a surface of type \ccc{Implicit_surface_3<Traits,Function>},
 the  surface mesher traits generator generates automatically
a traits class that is a model of \ccc{SurfaceMeshTraits_3}.
Actually, 
the concept \ccRefName\  provides the types, predicates and constructors 
that are passed 
to the generated model of \ccc{SurfaceMeshTraits_3}.


\ccTypes

\ccNestedType{FT}{The numerical type. It must be model of
  \ccc{SqrtFieldNumberType} and constructible from a \ccc{double}.}
\ccGlue
\ccNestedType{Point_3}{The point type. This point type must have a
  constructor \ccc{Point_3(FT, FT, FT)}.}
\ccGlue
\ccNestedType{Line_3}{The line type.}
\ccGlue
\ccNestedType{Ray_3}{The ray type.}
\ccGlue
\ccNestedType{Segment_3}{The segment type.}
\ccGlue
\ccNestedType{Vector_3}{The vector type.}
\ccGlue
\ccNestedType{Sphere_3}{The sphere type.}

\ccTwo{Construct_translated_point_3}{}

\ccNestedType{Compute_scalar_product_3}
{A function object that provides the operator\\
\ccc{FT operator()(Vector_3 v, Vector_3 w)} which returns the scalar
(inner) product of the two vectors \ccc{v} and \ccc{w}.}

\ccNestedType{Compute_squared_distance_3}
{A function object that provides the operator\\
\ccc{FT operator()(Point_3, Point_3)} which returns the squared distance
between two points.}

\ccNestedType{Compute_squared_radius_3}
{A function object providing the operator\\
\ccc{FT operator()(const Sphere_3& s)} which returns the squared radius
of~\ccc{s}.}

\ccNestedType{Construct_center_3}
{A function object providing the operator\\
\ccc{Point_3 operator()(const Sphere_3& s)} which computes the center of
the sphere~\ccc{s}.}

\ccNestedType{Construct_midpoint_3}
{A function object providing the operator\\
\ccc{Point_3 operator()(const Point_3& p, const Point_3& q)} which computes
the midpoint of the segment \ccc{pq}.}

\ccNestedType{Construct_point_on_3}
{A function object providing the following operators:\\
  \ccc{Point_3 operator()(const Line_3& l,int i);} which returns an
  arbitrary point on \ccc{l}. It holds \ccStyle{point(i) == point(j)}, iff
  \ccStyle{i==j}. Furthermore, is directed from \ccStyle{point(i)} to
  \ccStyle{point(j)}, for all \ccStyle{i} $<$ \ccStyle{j}.\\
  \ccc{Point_3 operator()(const Ray_3& r,int i);} which returns a point on
  \ccc{r}. \ccStyle{point(0)} is the source, \ccStyle{point(i)}, with
  $i>0$, is different from the source. \ccPrecond $i \geq 0$.\\
  \ccc{Point_3 operator()(const Segment_3& s,int i);} which returns source
  or target of \ccc{s}: \ccStyle{point(0)} returns the source of \ccc{s},
  \ccStyle{point(1)} returns the target of \ccc{s}. The parameter
  \ccStyle{i} is taken modulo 2, which gives easy access to the other end
  point.
}

\ccNestedType{Construct_segment_3}
{A function object providing the operators\\
  \ccc{Segment_3 operator()(const Point_3 &p, const Point_3 &q);} which
  returns a segment with source $p$ and target $q$. It is directed from the
  source towards the target.}

\ccNestedType{Construct_scaled_vector_3}
{A function object providing the operator\\
\ccc{Vector_3 operator()(const Vector_3 &v, const FT& scale)} which returns
the vector \ccc{v} scaled by a factor \ccc{scale}.}

\ccNestedType{Construct_translated_point_3}
{A function object providing the operator\\
\ccc{Point_3 operator()(const Point_3& p, const Vector_3& v)} which returns
the point obtained by translating \ccc{p} by the vector~\ccc{v}.}

\ccNestedType{Construct_vector_3}
{A function object providing the operator\\
\ccc{Vector_3 operator()(const Point_3 &a, const Point_3 &b)} which returns
the vector \ccc{b-a}.}

\ccNestedType{Has_on_bounded_side_3}
{A function object providing the operator\\
\ccc{bool operator()(const Sphere_3&s, const Point_3&p);} which
returns true iff $p$ lies on the bounded side of $s$.}

\ccOperations

The following functions give access to the predicate and construction
objects:

\ccThree{onstruct_translated_point_3xxx}{construct_translated_point_3_object()x}{}
\ccCreationVariable{traits}

\ccMethod{Compute_scalar_product_3 compute_scalar_product_3_object();}{}
\ccMethod{Compute_squared_distance_3 compute_squared_distance_3_object();}{}
\ccMethod{Compute_squared_radius_3 compute_squared_radius_3_object();}{}
\ccMethod{Construct_center_3 construct_center_3_object();}{}
\ccMethod{Construct_midpoint_3 construct_midpoint_3_object();}{}
\ccMethod{Construct_point_on_3 construct_point_on_3_object();}{}
\ccMethod{Construct_scaled_vector_3 construct_scaled_vector_3_object();}{}
\ccMethod{Construct_segment_3 construct_segment_3_object();}{}
\ccMethod{Construct_translated_point_3 construct_translated_point_3_object();}{}
\ccMethod{Construct_vector_3 construct_vector_3_object();}{}
\ccMethod{Has_on_bounded_side_3 has_on_bounded_side_3_object();}{}

\ccHasModels

Any \cgal\ Kernel.

\ccSeeAlso

\ccc{Implicit_surface_3<Traits, Function>},\\
\ccc{make_surface_mesh}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

