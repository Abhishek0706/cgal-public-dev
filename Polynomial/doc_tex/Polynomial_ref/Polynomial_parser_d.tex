% 
% \section{Introduction}
% 

\begin{ccRefClass}{Polynomial_parser_d< Poly_d_, ParserPolicy >}
\def\ccTagOperatorLayout{\ccFalse}

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccDefinition

The purpose of the polynomial parser is to provide an alternative way to input CGAL polynomials in a human-readable format. By default, the class \ccc{CGAL::Polynomial<Coeff>} provides an \ccc{operator >>} to read polynomials from an input stream in an ASCII format:
\begin{ccTexOnly}
\[
\begin{array}{l}
P[8(0,P[8(0,P[8(0,2)(2,-16)(4,80)(6,-128)(8,64)])(2,P[0(0,-16)])(4,P[0(0,80)])\\
\quad {}(6,P[0(0,-128)])(8,P[0(0,64)])])(2,P[0(0,P[0(0,-16)])])(4,P[0(0,P[0(0,80)])])\\
\quad {}(6,P[0(0,P[0(0,-128)])])(8,P[0(0,P[0(0,64)])])]
\end{array}
\]
\end{ccTexOnly}
\begin{ccHtmlOnly}
<span>oops..</span>
\end{ccHtmlOnly}
which corresponds to the following trivariate polynomial:
\begin{ccTexOnly}
\[\begin{array}{l}
64z^8 + (-128)z^6 + 80z^4 + (-16)z^2 + (64y^8 + (-128)y^6 + 80y^4 + (-16)y^2 + \\
\quad {}(64x^8 + (-128)x^6 + 80x^4 + (-16)x^2 + 2)).
\end{array}\]
\end{ccTexOnly}
\begin{ccHtmlOnly}
<span>oops..</span>
\end{ccHtmlOnly}
The parser can handle polynomials in any number of indeterminates (variables) and 
can parse arbitrary algebraic expressions, e.g., those of the form: 
\begin{ccTexOnly}
\[\begin{array}{l}
((y-1)^4 - x*y^3)^5 + (x + z)^2 - (2123234523*x^2 - 2*y*y*x + 3^{10}*x*132123)^3,\\
\quad {}(y + x - z + w - 3)^3 = x + y - 123/12312 + 1.00001*z*x^2.
\end{array}\]
\end{ccTexOnly}
\begin{ccHtmlOnly}
<span>oops..</span>
\end{ccHtmlOnly}
Note that, the multiplication symbol (*) is optional and can be omitted in the above expressions.

The parser's behavior is fully customizeable vie the so-called {\em parser policy} 
which is supplied as a template parameter to the parser. 
In the first place, the policy is responsible for reading polynomial 
coefficients from the input stream and performing all necessary type conversions
for the output polynomial. This, for instance, allows us to mix integer, rational and 
floating-point numbers in a single expression as demonstrated in the above examples.
Besides, the parser policy can be used to perform maximal degree check,
detect various erroneous situations (such as division by zero) 
or rename polynomial variables.

\ccParameters
The parser is instantiated with a type 
of polynomials constructed \ccc{Poly_d_} and the corresponding parser policy \ccc{ParserPolicy}. 


\ccCreation
\ccCreationVariable{parser}

% \ccConstructor{Weighted_alpha_shape_2(
%         const ParserPolicy& policy_ = ParserPolicy());}
% 
% {Default constructor, initializes from \ccc{policy_} object}

\ccConstructor{parser(
                const ParserPolicy& policy_ = ParserPolicy());}
{Default constructor, initializes from \ccc{policy_} object.}

\ccOperations

\ccMethod{bool 
operator()
(const std::string& in, Poly_d_& poly);}
{Parses the input string \ccc{in} and constructs the resulting polynomial \ccc{poly}. 
Returns \ccc{true} if parsing was successful.} 

Any user-defined parser policy must be the model of the \ccc{ParserPolicy}
concept defined below.
\end{ccRefClass}

\begin{ccRefConcept}{ParserPolicy}

\ccDefinition

Parser policy concept defines interface which any custom policy must provide.

\ccConstants

\ccVariable{static const char *var_names_lower;}{Variable names in lower case, given without delimiters, in the order from innermost to the outermost variable, e.g., ``xyzw''}
\ccVariable{static const char *var_names_upper;}{Variable names in upper case, given without delimiters, in the order from innermost to the outermost variable, e.g., ``XYZW''}
\ccVariable{static const int n_var_names;}{The number of variable names in the above arrays.}

\ccTypes

\ccCreationVariable{policy}

\ccNestedType{Poly_d}{Type of the output polynomial to be constructed.}\ccGlue
\ccNestedType{Input_coeff}{Type of polynomial coefficients as they are read from the input stream using \ccc{operator >>}. This can differ from the 
innermost coefficient type of \ccc{Poly_d} if any type conversions take place.}\ccGlue
\ccNestedType{Coeff}{Innermost coefficient type of \ccc{Poly_d}.}

\ccOperations
\ccMethod{Coeff read_coefficient(std::istream& is) const;}
{Reads a polynomial coefficient from the input stream \ccc{is} and converts it to the output type \ccc{Coeff}, \ccc{is} points to the first digit character of the coefficient. Throws an exception of type \ccc{Parser_exception} in case of error.}

\ccMethod{bool exponent_check(unsigned deg);}
{Performs exponent check on the polynomial coefficients. Returns \ccc{true}
if the degree \ccc{deg} of a monomial being parsed lies within the accepted range and \ccc{false} otherwise.}

\ccHasModels
\ccc{CGAL::Default_parser_policy< Poly_d_, InputCoeff >}\\
\ccc{CGAL::Mixed_rational_parser_policy< Poly_d_ >}\\
\ccc{CGAL::Mixed_floating_point_parser_policy< Poly_d_ >}\\

If no \ccc{ParserPolicy} template parameter is supplied to the parser class,
then the parser is instantiated with a default parser policy. 

\end{ccRefConcept}

\begin{ccRefClass} {Default_parser_policy< Poly_d_, InputCoeff >}

\ccDefinition
The default policy provides no type explicit conversions: in other words, polynomials are parsed ``as it is'' implying that there must be implicit type coercion between coefficients read from the input stream and the resulting polynomial coefficients. There must be an implicit type coercion between {\tt InputCoeff} and the type of innermost (scalar) coefficients of {\tt Poly\_d\_}.

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccTypes

\ccNestedType{Poly_d}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Input_coeff}{See \ccc{ParserPolicy} concept.}\ccGlue

% \ccInheritsFrom
% \ccc{Fb}

\ccCreation
\ccCreationVariable{default_policy}

\ccConstructor{Default_parser_policy();}
{Default constructor.}

\ccIncludeExampleCode{Polynomial/default_parser_policy.cpp}

\end{ccRefClass}

\begin{ccRefClass} {Mixed_rational_parser_policy< Poly_d_, InputCoeff >}

\ccDefinition
This parser policy allows mixing rational and integer coefficients in the same expression. \ccc{Poly_d_} must be a polynomial with rational coefficients or, otherwise, there must be an implicit coercion between \ccc{Rational} number type as defined below and
the innermost coefficients type of \ccc{Poly_d_}. 

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccInheritsFrom
\ccc{Default_parser_policy}

\ccTypes

\ccNestedType{Poly_d}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Input_coeff}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Integer}{Integer number type provided by \ccc{ArithmeticKernel} for \ccc{Input_coeff} number type.}\ccGlue
\ccNestedType{Rational}{Rational number type provided by \ccc{ArithmeticKernel} for \ccc{Input_coeff} number type.}\ccGlue


\ccCreation
\ccCreationVariable{rat_policy}

\ccConstructor{Mixed_rational_parser_policy();}
{Default constructor.}

\ccIncludeExampleCode{Polynomial/mixed_rational_parser_policy.cpp}


\end{ccRefClass}

\begin{ccRefClass} {Mixed_floating_point_parser_policy< Poly_d_, InputCoeff >}

\ccDefinition
This parser policy allows mixing rational and integer and floating-point (BigFloat) coefficients in the same expression. \ccc{Poly_d_} must be a polynomial with rational coefficients or, otherwise, there must be an implicit coercion between \ccc{Rational} number type as defined below and
the innermost coefficients type of \ccc{Poly_d_}. 

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccInheritsFrom
\ccc{Mixed_rational_parser_policy}

\ccTypes

\ccNestedType{Poly_d}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Input_coeff}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Integer}{Integer number type provided by \ccc{ArithmeticKernel} for \ccc{Input_coeff} number type.}\ccGlue
\ccNestedType{Rational}{Rational number type provided by \ccc{ArithmeticKernel} for \ccc{Input_coeff} number type.}\ccGlue
\ccNestedType{BigFloat}{BigFloat number type provided by \ccc{ArithmeticKernel} for \ccc{Input_coeff} number type.}\ccGlue

\ccCreation
\ccCreationVariable{fp_policy}

\ccConstructor{Mixed_floating_point_parser_policy();}
{Default constructor.}

\ccIncludeExampleCode{Polynomial/mixed_floating_point_parser_policy.cpp}


\end{ccRefClass}


% \ccCreation
% \ccConstructor{Alpha_shape_vertex_base_3();}{default constructor.}
% \ccGlue


% \ccInheritsFrom
% 
% \ccStyle{Alpha_shape_2<Rt>}
% \begin{lstlisting}[frame=none]
% template < class Poly_d_, class InputCoeff >
% struct Default_parser_policy {
%     // first template argument type
%     typedef Poly_d_ Poly_d;
%     // second template argument type
%     typedef InputCoeff Input_coeff;
%     // coefficient type
%     typedef typename  CGAL::Polynomial_traits_d< Poly_d >::
%         Innermost_coefficient_type Coeff;
% 
%     // default constructor
%     Default_parser_policy() { }
%     
%     // reads a coefficient from the input stream 
%     Coeff read_coefficient(std::istream& is) const;
% 
%     // check for degree overflow
%     virtual bool exponent_check(unsigned) const {
%         return true;
%     }
% 
%     virtual ~Default_parser_policy() { }
% 
%     // variable names listed in the order from innermost to the outermost
%     // variable as they appear in the resulting equation
%     static const int n_var_names = 4;    
%     static const char *var_names_lower, *var_names_upper;
%     ...
% };
% \end{lstlisting}
% The first template parameter, {\tt Poly\_d\_}, is a type of output polynomial while 
% the second one, {\tt InputCoeff}, defines the type of polynomial coefficients as
% they are read from the input stream via {\tt operator >>}. 
% There must be an implicit type coercion between {\tt InputCoeff} and 
% the type of innermost (scalar) coefficients of {\tt Poly\_d\_}.
%



% 
% Besides, the "parser policy" offers a great flexibility in controlling the way how the output polynomials are constructed.
% All type conversions, precision and rounding of polynomial coefficients are ultimately handled by a given parser policy,
% which completely separates the parser from the number type issues.
% 
% 
% 
% 
%  
