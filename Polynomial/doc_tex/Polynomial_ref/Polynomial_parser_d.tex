% 
% \section{Introduction}
% 

\begin{ccRefClass}{Polynomial_parser_d< Polynomial_d_, ParserPolicy >}
\def\ccTagOperatorLayout{\ccFalse}

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccDefinition

The polynomial parser provide the functionality to read polynomials in a human-readable format which
is not directly supported by \ccc{operator >>} of \ccc{CGAL::Polynomial<Coeff>}. However, note that,
the polynomial parser is \ccc{not} a replacement or extension of the default \ccc{operator >>}. Instead,
it is available as an independent feature..

The parser's behavior is fully customizeable via the so-called {\em parser policy} 
which is supplied as a template parameter to the parser. 
In the first place, the policy is responsible for reading polynomial 
coefficients from the input stream and performing all necessary type conversions
for the output polynomial. This, for instance, allows us to mix integer, rational and 
floating-point numbers in a single expression (for examples, please see CGAL users manual).
Besides, the parser policy can be used to perform maximal degree check,
detect various erroneous situations (such as division by zero) 
or rename polynomial variables.

\ccParameters
The parser is instantiated with a type 
of polynomials constructed \ccc{Polynomial_d_} and the corresponding parser policy \ccc{ParserPolicy}. 


\ccCreation
\ccCreationVariable{parser}

% \ccConstructor{Weighted_alpha_shape_2(
%         const ParserPolicy& policy_ = ParserPolicy());}
% 
% {Default constructor, initializes from \ccc{policy_} object}

\ccConstructor{parser(
                const ParserPolicy& policy_ = ParserPolicy());}
{Default constructor, initializes from \ccc{policy_} object.}

\ccOperations

\ccMethod{bool 
operator()
(const std::string& in, Polynomial_d_& poly);}
{Parses the input string \ccc{in} and constructs the resulting polynomial \ccc{poly}. 
Returns \ccc{true} if parsing was successful.} 

Any user-defined parser policy must be the model of the \ccc{ParserPolicy}
concept defined below.
\end{ccRefClass}

\begin{ccRefConcept}{ParserPolicy}

\ccDefinition

Parser policy concept defines interface which any custom policy must provide.

\ccConstants

\ccVariable{static const char *var_names_lower;}{Variable names in lower case, given without delimiters, in the order from innermost to the outermost variable, e.g., ``xyzw''}
\ccVariable{static const char *var_names_upper;}{Variable names in upper case, given without delimiters, in the order from innermost to the outermost variable, e.g., ``XYZW''}
\ccVariable{static const int n_var_names;}{The number of variable names in the above arrays.}

\ccTypes

\ccCreationVariable{policy}

\ccNestedType{Polynomial_d}{Type of the output polynomial to be constructed.}
\ccGlue
\ccNestedType{Coeff}{Innermost coefficient type of \ccc{Polynomial_d}.}

\ccOperations
\ccMethod{Coeff read_coefficient(std::istream& is) const;}
{Reads a polynomial coefficient from the input stream \ccc{is} and converts it to the output type \ccc{Coeff}, \ccc{is} points to the first digit character of the coefficient. Throws an exception of type \ccc{Parser_exception} in case of error.}

\ccMethod{bool exponent_check(unsigned deg);}
{Performs exponent check on the polynomial coefficients. Returns \ccc{true}
if the degree \ccc{deg} of a monomial being parsed lies within the accepted range and \ccc{false} otherwise.}

\ccHasModels
\ccc{CGAL::Default_parser_policy< Polynomial_d_ >}\\
\ccc{CGAL::Mixed_rational_parser_policy< Polynomial_d_ >}\\
\ccc{CGAL::Mixed_floating_point_parser_policy< Polynomial_d_ >}\\

If no \ccc{ParserPolicy} template parameter is supplied to the parser class,
then the parser is instantiated with a default parser policy. 

\ccSeeAlso
% \ccRefIdfierPage{Polynomial_parser_d}\\
\ccRefIdfierPage{CGAL::Polynomial_parser_d< Polynomial_d_, ParserPolicy >}

\end{ccRefConcept}

\begin{ccRefClass} {Default_parser_policy< Polynomial_d_ >}

\ccDefinition
The default policy provides no type explicit conversions: in other words, polynomials are parsed ``as it is'', the coefficients of type \ccc{Polynomial_d_::Innermost_coefficient_type} are read from the input stream and are used to construct the resulting polynomial.

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccTypes

\ccNestedType{Polynomial_d}{See \ccc{ParserPolicy} concept.}\ccGlue

% \ccInheritsFrom
% \ccc{Fb}

\ccCreation
\ccCreationVariable{default_policy}

\ccConstructor{Default_parser_policy();}
{Default constructor.}

\end{ccRefClass}

\begin{ccRefClass} {Mixed_rational_parser_policy< Polynomial_d_ >}

\ccDefinition
This parser policy allows mixing rational and integer coefficients in the same expression. \ccc{Polynomial_d_} must be a polynomial with rational coefficients or, otherwise, there must be an implicit coercion between \ccc{Rational} number type as defined below and
the innermost coefficients type of \ccc{Polynomial_d_}. 

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccInheritsFrom
\ccc{Default_parser_policy}

\ccTypes

\ccNestedType{Polynomial_d}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Coeff}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Integer}{Integer number type provided by \ccc{ArithmeticKernel} for \ccc{Coeff} number type.}\ccGlue
\ccNestedType{Rational}{Rational number type provided by \ccc{ArithmeticKernel} for \ccc{Coeff} number type.}\ccGlue


\ccCreation
\ccCreationVariable{rat_policy}

\ccConstructor{Mixed_rational_parser_policy();}
{Default constructor.}

\end{ccRefClass}

\begin{ccRefClass} {Mixed_floating_point_parser_policy< Polynomial_d_ >}

\ccDefinition
This parser policy allows mixing rational and integer and floating-point (BigFloat) coefficients in the same expression. \ccc{Polynomial_d_} must be a polynomial with rational coefficients or, otherwise, there must be an implicit coercion between \ccc{Rational} number type as defined below and
the innermost coefficients type of \ccc{Polynomial_d_}. 

\ccInclude{CGAL/Polynomial/Polynomial_parser_d.h}

\ccIsModel
\ccc{ParserPolicy}

\ccInheritsFrom
\ccc{Mixed_rational_parser_policy}

\ccTypes

\ccNestedType{Polynomial_d}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Coeff}{See \ccc{ParserPolicy} concept.}\ccGlue
\ccNestedType{Integer}{Integer number type provided by \ccc{ArithmeticKernel} for \ccc{Coeff} number type.}\ccGlue
\ccNestedType{Rational}{Rational number type provided by \ccc{ArithmeticKernel} for \ccc{Coeff} number type.}\ccGlue
\ccNestedType{BigFloat}{BigFloat number type provided by \ccc{ArithmeticKernel} for \ccc{Coeff} number type.}\ccGlue

\ccCreation
\ccCreationVariable{fp_policy}

\ccConstructor{Mixed_floating_point_parser_policy();}
{Default constructor.}

\end{ccRefClass}


% \ccCreation
% \ccConstructor{Alpha_shape_vertex_base_3();}{default constructor.}
% \ccGlue


% \ccInheritsFrom
% 
% \ccStyle{Alpha_shape_2<Rt>}
% \begin{lstlisting}[frame=none]
% template < class Polynomial_d_, class InputCoeff >
% struct Default_parser_policy {
%     // first template argument type
%     typedef Polynomial_d_ Polynomial_d;
%     // second template argument type
%     typedef InputCoeff Input_coeff;
%     // coefficient type
%     typedef typename  CGAL::Polynomial_traits_d< Polynomial_d >::
%         Innermost_coefficient_type Coeff;
% 
%     // default constructor
%     Default_parser_policy() { }
%     
%     // reads a coefficient from the input stream 
%     Coeff read_coefficient(std::istream& is) const;
% 
%     // check for degree overflow
%     virtual bool exponent_check(unsigned) const {
%         return true;
%     }
% 
%     virtual ~Default_parser_policy() { }
% 
%     // variable names listed in the order from innermost to the outermost
%     // variable as they appear in the resulting equation
%     static const int n_var_names = 4;    
%     static const char *var_names_lower, *var_names_upper;
%     ...
% };
% \end{lstlisting}
% The first template parameter, {\tt Poly\_d\_}, is a type of output polynomial while 
% the second one, {\tt InputCoeff}, defines the type of polynomial coefficients as
% they are read from the input stream via {\tt operator >>}. 
% There must be an implicit type coercion between {\tt InputCoeff} and 
% the type of innermost (scalar) coefficients of {\tt Poly\_d\_}.
%



% 
% Besides, the "parser policy" offers a great flexibility in controlling the way how the output polynomials are constructed.
% All type conversions, precision and rounding of polynomial coefficients are ultimately handled by a given parser policy,
% which completely separates the parser from the number type issues.
% 
% 
% 
% 
%  
