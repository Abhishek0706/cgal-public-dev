#! /bin/sh
#
# This is the test script for the CGAL-library.
#
# Usage:
#   run_testsuite                  for running the test suite in all subdirectories
#   run_testsuite <directory-list> for running the test suite in the listed
#                                  subdirectories
#
# To use this script you have to do two things:
#
# 2) set some additional compiler and or linker flags

TESTSUITE_CXXFLAGS=""
TESTSUITE_LDFLAGS=""

CURRENTDIR=`pwd`
ERRORFILE=${CURRENTDIR}/error.txt
PLATFORM=$CGAL_TEST_PLATFORM

#clear the error file
rm -f $ERRORFILE
touch $ERRORFILE

# Wait for process with pid $1.
# Wait for $2 periods of $3 seconds, checking after every period
# if the watched process has finished.
wait_for_process()
{
    pid=$1;
    cycles=$2
    period=$3
    while [ $cycles -ne 0 ]
    do
        cycles=`expr $cycles - 1`  
# send SIGCONT to the process and check the exit value of kill.
# If the process still exists, the call to kill succeeds (and the signal is
# ignored).
        
        kill -CONT $pid 2>kill_output 1>/dev/null;   terminated=$?
# But under CYGWIN the exit status is not to be trusted.
	if [ $terminated -eq 0 ]; then
	    if grep -i 'no such process' kill_output; then
		terminated=1;
	    fi
	fi
	rm -f kill_output
	if [ $terminated -eq 0 ]
        then
            sleep $period
        else
            cycles=0
            running=0
        fi
    done
    if [ $terminated -eq 0 ]
    then
    	if false; then
# Send signal Terminate (SIGTERM) to the whole process group.
# First disable the default action (quit) for the current process.
	    trap true TERM
	    kill -TERM 0
	    trap TERM
	else

	    # $pid is the PID of the forked shell that launched the command
	    # in background, in run_local_cgal_test(). If the shell is
	    # Bash, the Bash manual states that it ignores SIGTERM.
	    # However, it does not catch SIGHUP. That is why the first
	    # signal send is SIGHUP.
	    kill -HUP $pid
	    sleep 10
	    # If SIGHUP was not enough, SIGKILL will finish the job, 10s after.
	    kill -KILL -$pid
	fi
        return 1  
    fi
    return 0
}

run_local_cgal_test()
{
    eval ./cgal_test_with_cmake > current_compiler_output 2>&1
    exit_value=$?
    if [ $exit_value -ne 0 ]
    then
         printf "%s\n" "$exit_value" > test_failure
    fi
}

#test_directory <directory>
test_directory()
{
  cd $CURRENTDIR
  if [ -d $1 ] ; then
    echo "DIRECTORY $1:"                
    echo                                

    echo "DIRECTORY $1:"                 >> $ERRORFILE
    echo                                 >> $ERRORFILE
    cd $1

    COMPILER_OUTPUT=CompilerOutput_$PLATFORM
    rm -f $COMPILER_OUTPUT
    ERROR_OUTPUT=ErrorOutput_$PLATFORM
    rm -f $ERROR_OUTPUT

    echo "------------------------------------------------------------------" >> $COMPILER_OUTPUT
    echo "- Compiler output from platform $PLATFORM"                          >> $COMPILER_OUTPUT
    echo "------------------------------------------------------------------" >> $COMPILER_OUTPUT
    echo                                                                      >> $COMPILER_OUTPUT

    echo "------------------------------------------------------------------" >> $ERROR_OUTPUT
    echo "- Error output from platform $PLATFORM"                             >> $ERROR_OUTPUT
    echo "------------------------------------------------------------------" >> $ERROR_OUTPUT
    echo                                                                      >> $ERROR_OUTPUT

    if [ -f cgal_test_with_cmake -a -x cgal_test_with_cmake ] ; then
      export PLATFORM TESTSUITE_CXXFLAGS TESTSUITE_LDFLAGS
      rm -f error.txt
      run_local_cgal_test &

      if wait_for_process "$!" "1200" "5"
      then
	if [ -f test_failure  ] ; then
            exit_failure=`cat test_failure`
	    rm -f test_failure
	    echo "ERROR: cgal_test_with_cmake exited with error condition $exit_value" >> $ERRORFILE
	    echo "ERROR: cgal_test_with_cmake exited with error condition $exit_value" >> $ERROR_OUTPUT
	fi
      else
	echo "ERROR: cgal_test_with_cmake did not finish within the time bound set" >> $ERRORFILE
	echo "ERROR: cgal_test_with_cmake did not finish within the time bound set" >> $ERROR_OUTPUT
      fi
      cat current_compiler_output >> $COMPILER_OUTPUT
      cat current_compiler_output
      rm -f current_compiler_output 

      if [ -f error.txt ] ; then
        cat error.txt >> $ERRORFILE
        cat error.txt >> $ERROR_OUTPUT
      else
        echo "ERROR: the script cgal_test_with_cmake failed to generate output" >> $ERRORFILE
      fi
    else
      echo "      Could not execute the script cgal_test_with_cmake in directory $1"
      echo "ERROR: could not execute the script $1/cgal_test_with_cmake" >> $ERRORFILE
    fi
    echo >> $ERRORFILE
    echo >> $ERROR_OUTPUT
  fi
  echo
}

run_testsuite()
{
  
  echo "---------------------------------------------------------------"
  echo "- Testing platform $PLATFORM"                         
  echo "---------------------------------------------------------------"
  echo                                                                  

  echo "---------------------------------------------------------------" >> $ERRORFILE
  echo "- TEST RESULTS FROM PLATFORM $PLATFORM"                          >> $ERRORFILE
  echo "---------------------------------------------------------------" >> $ERRORFILE
  echo                                                                   >> $ERRORFILE

  for DIR in $TEST_DIRECTORIES ; do
    test_directory $DIR
  done
}

[ x"$1" = x"icons" -o x"$1" = x"resources" ] && exit 0

if [ -z "$1" ] ; then
  TEST_DIRECTORIES=`pwd`
else
  TEST_DIRECTORIES="$*"
fi

run_testsuite

