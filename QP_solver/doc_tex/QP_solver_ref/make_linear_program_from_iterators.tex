\begin{ccRefFunction}{make_linear_program_from_iterators}

\ccInclude{CGAL/QP_models.h}

This template function creates an instance of 
\ccc{Linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>} from given iterators. This function can be useful if the types of these
iterators are too complicated (or of too little interest for you) 
to write them down explicitly.

Note that this way of constructing linear programs is not
the most efficient, because internally, all computations are done using
a sparse representation of \ccc{A_it}. If possible,
use \ccc{make_linear_program_from_sparse_iterators}.

\ccFunction{template <
   A_it,   
   B_it,   
   R_it,   
   FL_it,  
   L_it,   
   FU_it, 
   U_it,   
   C_it >  
Linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>
make_linear_program_from_iterators (
   int n, int m, 
   const A_it& a, 
   const B_it& b, 
   const R_it& r, 
   const FL_it& fl, 
   const L_it& l,
   const FU_it& fu, 
   const U_it& u, 
   const C_it& c, 
   std::iterator_traits<C_it>::value_type c0 = 
   std::iterator_traits<C_it>::value_type(0));}
{returns an instance of \ccc{Linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>}, constructed from the given iterators.}

\ccExample
The following example demonstrates the typical usage of makers
with the simpler function \ccc{make_nonnegative_linear_program_from_iterators}.

\ccReferToExampleCode{QP_solver/solve_convex_hull_containment_lp2.h}\\
\ccReferToExampleCode{QP_solver/convex_hull_containment2.cpp}

\ccSeeAlso
\ccc{Linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>}
\ccc{make_linear_program_from_sparse_iterators}
\end{ccRefFunction}
