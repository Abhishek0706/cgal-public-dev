\begin{ccRefClass}{Nonnegative_quadratic_program_from_sparse_iterators<A_s_it, B_it, R_it, D_s_it, C_it>}

\ccInclude{CGAL/QP_models.h}

\ccDefinition
An object of class \ccRefName\ describes a convex quadratic program of the form

\input{QP_solver_ref/_nqp_description.tex}

\input{QP_solver_ref/_from_iterator_description.tex}

\ccIsModel
\ccc{QuadraticProgram}\\
\ccc{NonnegativeQuadraticProgram}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{qp}

\ccConstructor{Nonnegative_quadratic_program_from_iterators(int n, int m, 
  const A_s_it& a, 
  const B_it& b,
  const R_it& r,
  const D_s_it& d,
  const C_it& c,
  const std::iterator_traits<C_it>value_type& c0 = 0
  )}{constructs \ccVar\ from given random-access iterators, the sparse iterator \ccc{A_s_it} and \ccc{D_s_it}, and the constant \ccc{c0}. The passed iterators are merely stored, no copying of the program data takes place. How these iterators are supposed to encode the nonnegative
quadratic program is described in \ccc{NonnegativeQuadraticProgram}.}

\ccExample

\ccReferToExampleCode{QP_solver/first_nonnegative_qp_from_iterators.cpp}

The following example for the simpler model
\ccc{Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>} 
should give you a flavor of the use of this 
model in practice.

\ccReferToExampleCode{QP_solver/solve_convex_hull_containment_lp.h}\\
\ccReferToExampleCode{QP_solver/convex_hull_containment.cpp}

\ccSeeAlso
\ccc{NonnegativeQuadraticProgram}
\ccc{Quadratic_program<NT>}\\
\ccc{Quadratic_program_from_mps<NT>}
\end{ccRefClass}
